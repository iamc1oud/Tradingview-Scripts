//@version=5  
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //

// ---------------------------------------------------------------------------------------------- //
// Functions

f_drawOnlyLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)

f_drawLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    var id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)

    if _y1 > 0 and _y2 > 0
        line.set_xy1(id, _x1, _y1)
        line.set_xy2(id, _x2, _y2)
        line.set_color(id, _color)
    else
        line.set_xy1(id, _x1, close)
        line.set_xy2(id, _x2, close)
        line.set_color(id, #00000000)

f_drawOnlyLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)

f_drawLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    var id = label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)
    label.set_text(id, _text)
    label.set_tooltip(id, _tooltip)
    
    if _y > 0
        label.set_xy(id, _x, _y)
        label.set_textcolor(id, _textcolor)
    else
        label.set_xy(id, _x, close)
        label.set_textcolor(id, #00000000)

f_calculatePreviousRange(_htf) =>
    var htf_h  = 0., var htf_l  = 0., var htf_hx = 0., var htf_lx = 0.

    if ta.change(time(_htf))
        htf_hx := htf_h, htf_h  := high
        htf_lx := htf_l, htf_l  := low
        true
    else
        htf_h := math.max(high, htf_h)
        htf_l := math.min(low , htf_l)
        true

    [htf_hx, htf_lx]

f_getTradedVolume(_len, _calc, _offset) =>
    if _calc
        vol   = 0.
        for x = 0 to _len - 1
            vol += volume[_offset + x]
        vol

f_getMA(_source, _length, _type) => 
    switch _type
        "SMA"  => ta.sma (_source, _length)
        "EMA"  => ta.ema (_source, _length)
        "HMA"  => ta.hma (_source, _length)
        "WMA"  => ta.wma (_source, _length)

f_getATR(_length, _htf) =>
    request.security(syminfo.tickerid, _htf, ta.atr(_length))


indicator('Day Trading', 'Day Trading', true, max_lines_count=500, max_labels_count=500)

// ---------------------------------------------------------------------------------------------- //
// Input Declarations

group_fx = "Forex Markets"

ttip_channel = 'Asian Session Opening Channel is the range between Tokyo Open and Hong Kong Open\n' +
               'Europien Session Opening Channel is the range between Frankfurt Open and London Open\n\n' +
               'Channel plotting starts from Tokyo or Frankfurt open, based on the option selected, and extends till the day session end'

openingChannel = input.string('None' , 'Openning Channel'  , options = ['Asian Session', 'European Session', 'Both', 'None'], inline='ss', group = group_fx, tooltip = ttip_channel)
cChannel       = input.color(color.gray, '', inline='ss', group = group_fx)

shSydney  = input.string('None' , 'Sydney Sessionâ€ƒ'  , options = ['Open', 'Range', '5m Opening Range', '15m Opening Range', 'None'], inline='SY' , group = group_fx)
cSydney   = input.color(color.navy, '', inline='SY', group = group_fx)
bgSydney  = true//input.bool(true, 'Range Fill', inline='SY', group = group_fx)
i_sydneySummerTime  = input.bool(true, 'DST', inline='SY' , group = group_fx, tooltip = 'Daylight saving time (DST)\n *DST Start : First Sunday in October at 2:00\n *DST End : First Sunday in April at 3:00')

shTokyo  = input.string('None' , 'Tokyo Sessionâ€ƒâ€ƒ'  , options = ['Open', 'Range', '5m Opening Range', '15m Opening Range', 'None'], inline='TK' , group = group_fx)
cTokyo   = input.color(color.fuchsia, '', inline='TK', group = group_fx)
bgTokyo  = true//input.bool(true, 'Range Fill', inline='TK', group = group_fx)

shFrankfurt  = input.string('5m Opening Range' , 'Frankfurt Session'  , options = ['Open', 'Range', '5m Opening Range', '15m Opening Range', 'None'], inline='FR' , group = group_fx)
cFrankfurt   = input.color(color.yellow, '', inline='FR', group = group_fx)
bgFrankfurt  = true//input.bool(true, 'Range Fill', inline='FR', group = group_fx)
i_frankfurtSummerTime  = input.bool(false , 'DST', inline='FR', group = group_fx, tooltip = 'Daylight saving time (DST)\n *DST Start : Last Sunday in March at 1:00 UTC\n *DST End : Last Sunday in October at 1:00 UTC')

shLondon  = input.string('5m Opening Range' , 'London Sessionâ€ƒ'  , options = ['Open', 'Range', '5m Opening Range', '15m Opening Range', 'None'], inline='LN' , group = group_fx)
cLondon   = input.color(color.blue, '', inline='LN', group = group_fx)
bgLondon  = true//input.bool(true, 'Range Fill', inline='LN', group = group_fx)
i_londonSummerTime  = input.bool(false , 'DST', inline='LN', group = group_fx, tooltip = 'Daylight saving time (DST)\n *DST Start : Last Sunday in March at 1:00 UTC\n *DST End : Last Sunday in October at 1:00 UTC')

shNYork  = input.string('15m Opening Range' , 'New York Session'  , options = ['Open', 'Range', '5m Opening Range', '15m Opening Range', 'None'], inline='NY' , group = group_fx)
cNYork   = input.color(color.green, '', inline='NY', group = group_fx)
bgNYork  = true//input.bool(true, 'Range Fill', inline='NY', group = group_fx)
i_newyorkSummerTime = input.bool(false , 'DST', inline='NY', group = group_fx, tooltip = 'Daylight saving time (DST)\n *DST Start : Second Sunday in March at 2:00\n *DST End : First Sunday in November at 2:00')

i_forex       = input.bool(true , 'Global Forex Market Sessions Tabular View'  , group = group_fx, tooltip = 'Displays Major Fortex Markets\n - Date and Time,\n - Sessions Opening/Closing Countdown Timer and\n - Market Status')
hideIfNot     = input.bool(true , 'Hide if not Forex Market Instrument'  , group = group_fx)
i_textSize2   = input.string("Small", "â€ƒâ€ƒTable Text Size", options = [ "Tiny", "Small", "Normal"], inline='STAT',group = group_fx)
textSize2           = i_textSize2 == "Small" ? size.small : i_textSize2 == "Normal" ? size.normal : size.tiny
statPos   = input.string('Top Right', '', options=['Top Left', 'Top Center', 'Top Right', 'Middle Right', 'Bottom Left', 'Bottom Center'], inline='STAT', group=group_fx) 

ttip_events   = 'A graphical presentation* of typically traded volume** and various forext markets oppening/clossing events***\n\n' +
                 '*   Will be presented on 1H or lower minute timeframes\n' +
                 '**  According to the two most popular currencies traded, U.S. dollar (USD) and the Euro (EUR). Trading volume may slightly vary for other currencies, especially Asian currencies\n' +
                 '*** Reminder, Daylight saving time is not taken into consideration so there may be slight differences'

forexEvents       = input.bool(true , 'Global Forex Market Events'  , group = group_fx, tooltip = ttip_events)
oscVerticalOffset = input.int(0, "â€ƒâ€ƒVertical Offset", minval = -3, maxval = 10, inline='evt', group = group_fx) / 10
oscHight          = 11 - input.int(7, 'Hight' , minval = 1, maxval = 10 ,inline='evt', group = group_fx)

group_htf = 'Higher Timeframe Open'

dayOpen      = input.string('5m Opening Range' , 'Day Openâ€ƒâ€ƒâ€ƒâ€ƒâ€ƒ'  , options = ['Open', '5m Opening Range', '15m Opening Range', 'First Hour Opening Range', 'None'], inline='DO' , group = group_htf)
dayColor     = input.color(color.aqua, '', inline = 'DO', group = group_htf)
dayRefLevels = input.string('Average True Range (ATR)', 'Day Referance Levels', options = ['Average True Range (ATR)', 'Previous Day Range (PH - PL)', 'None'], inline = 'REFL', group = group_htf)
dayRefColor  = input.color(color.orange, '', inline = 'REFL', group = group_htf)
dayRefLevel1 = input.float(.5, 'â€ƒâ€ƒReferance Level #1', minval=0, step=0.1, inline='Ref', group=group_htf)
dayRefLevel2 = input.float(1., '#2', minval=0, step=0.1, inline='Ref', group=group_htf)
dayATRLength = input.int(5, 'â€ƒâ€ƒATR Referance Levels : ATR Length', minval=1, inline='ATR', group=group_htf)

weekOpen   = input.bool(false , 'Week Open'  , inline='WO' , group = group_htf)
weekColor  = input.color(color.aqua, '', inline = 'WO', group = group_htf)
monthOpen  = input.bool(false , 'Month Open'  , inline='WO' , group = group_htf)
monthColor = input.color(color.aqua, '', inline = 'WO', group = group_htf)

group_indicators = 'Indicators'

ttip_vwap  = 'Volume Weighted Average Price (VWAP) is a technical analysis tool used to measure the average price weighted by volume. VWAP is typically used with intraday charts as a way to determine the general direction of intraday prices, that is to identify market trend'
ttip_vwapAnchor = 'Auto input mode : the starting point of the VWAP calculation depends on the timeframe on the chart:\n' +
                  ' - "Day" on intraday timeframes up to 15 Mins\n' +
                  ' - "Week" on intraday timeframes higher than 15 Mins\n' +
                  ' - "Month" on the 1D timeframe\n' +
                  ' - "Quarter" on the 1W timeframe\n' +
                  ' - "Year" on the 1M timeframe\n\n' +
                  'Interactive input mode : enables selecting the starting point of the VWAP calculation by simply dragging the vertical line* on the chart\n  *the vertical line appears when any of the indicators plotted components are clicked\n\n' +
                  'Manuel input mode (other options) : enables to specify a fixed anchor period regardless of the chart timeframe'

isVwap     = input.bool(false, 'Volume Weighted Average Price (VWAP) ----------|', group=group_indicators, tooltip = ttip_vwap)
htf_tf     = input.string('Auto', 'Anchor Timeframe', options=['Auto', 'Interactive', '15 Minutes', '1 Hour', '4 Hours', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly'], inline = 'vwap', group=group_indicators, tooltip = ttip_vwapAnchor)
vwapAnchor = htf_tf == '15 Minutes' ? '15' : htf_tf == '1 Hour' ? '60' : htf_tf == '4 Hours' ? '240' :  htf_tf == 'Daily' ? 'D' : htf_tf == 'Weekly' ? 'W' : htf_tf == 'Monthly' ? 'M' : htf_tf == 'Quarterly' ? '3M' : htf_tf == 'Yearly' ? '12M' : 
          timeframe.isintraday and (timeframe.period == '1'  or timeframe.period == '3'  or timeframe.period == '5'  or timeframe.period == '15') ? 'D' : 
          timeframe.isintraday and (timeframe.period == '30' or timeframe.period == '45' or timeframe.period == '60' or timeframe.period == '120' or timeframe.period == '180' or timeframe.period == '240') ? 'W' : 
          timeframe.isdaily ? 'M' : timeframe.isweekly ? '3M' : timeframe.ismonthly ? '12M' : '3M'

vwapSource = input.source(hlc3, 'Source', inline = 'vwap', group=group_indicators)
startDate  = input.time(timestamp("29 Nov 2022"), "Interactive Anchor", inline = 'inn', group=group_indicators)
vwapBand1  = input.bool(true,"Bands #1", inline = 'B1', group=group_indicators)
stdevMult1 = input.float(1, "", step = .1, inline = 'B1', group=group_indicators)
vwapBand2  = input.bool(false,"#2", inline = 'B1', group=group_indicators)
stdevMult2 = input.float(2, "", step = .1, inline = 'B1', group=group_indicators)
//vwapBand3  = input.bool(false,"Bands stDev #3", inline = 'B3', group=group_indicators)
//stdevMult3 = input.float(3, "", inline = 'B3', group=group_indicators)

tooltip_pvt = 'The Pivot Points High Low indicator is used to determine and anticipate potential changes in market price and reversals. By analyzing price changes and reversals, a trader has more of an ability to determine and predict price patterns and general price trends\n\n' +
              'This custom interpretation of Pivot Points High Low indicator; \n' + 
              ' - beside calculating Pivot Highs/Lows based on the given length it also calculates and detects short term Pivot Highs/Lows\n' +
              ' - calculates price changes, traded volume etc between any two Pivot High/Low'

dispPVT   = input.bool(true , 'Pivot Points High Lowâ€ƒâ€ƒ---------------------------|', group=group_indicators, tooltip=tooltip_pvt)
pvtLength = input.int(20, "â€ƒâ€ƒLeft/Right Length", minval=1, group=group_indicators)
pvtText   = input.string('Small', "â€ƒâ€ƒLabel Text Size", options=['Tiny', 'Small', 'Normal'], group=group_indicators)
pvtTextSize = pvtText == 'Small' ? size.small : pvtText == 'Normal' ? size.normal : size.tiny
pvtPrice  = input(true, "Price", inline = 'Levels', group=group_indicators)
pvtChange = input(false, "Price Change", inline = 'Levels', group=group_indicators)
pvtVolume = input(false, "Cumulative Volume", inline = 'Levels', group=group_indicators)

ttip_ma    = 'A Moving Average is a good way to gauge momentum as well as to confirm trends, and define areas of support and resistance.'

maDisplay  = input.bool(false , 'Moving Averageâ€ƒâ€ƒ----------------------------------|', group=group_indicators, tooltip=ttip_ma)
maType     = input.string('EMA', '', options=['SMA', 'EMA', 'WMA', 'HMA'], inline = 'MA', group = group_indicators)
maSource   = input.source(close,    "",  inline = 'MA', group = group_indicators)
maLength   = input.int(50,    "", minval = 1, inline = 'MA', group = group_indicators)
maColor    = input.color(color.orange, '', inline = 'MA', group = group_indicators)
maType2     = input.string('EMA', '', options=['SMA', 'EMA', 'WMA', 'HMA'], inline = 'MA2', group = group_indicators)
maSource2   = input.source(close,    "",  inline = 'MA2', group = group_indicators)
maLength2   = input.int(200,    "", minval = 1, inline = 'MA2', group = group_indicators)
maColor2    = input.color(color.teal, '', inline = 'MA2', group = group_indicators)
maType3     = input.string('EMA', '', options=['SMA', 'EMA', 'WMA', 'HMA'], inline = 'MA2', group = group_indicators)
maSource3   = input.source(close,    "",  inline = 'MA3', group = group_indicators)
maLength3   = input.int(365,    "", minval = 1, inline = 'MA3', group = group_indicators)
maColor3    = input.color(color.blue, '', inline = 'MA3', group = group_indicators)

// ---------------------------------------------------------------------------------------------- //
// Variable Declarations

var a_majorCity     = array.new_string()
var a_utcTimeOffset = array.new_float()
var a_utcCity       = array.new_string()

var a_forexMarket   = array.new_string()
var a_forexOpenH    = array.new_float()
var a_forexCloseH   = array.new_float()

var a_forexEvents   = array.new_string()
var a_tradingVolume = array.new_float()

dayChange    = timeframe.change('D')
weekChange   = timeframe.change('W')
monthChange  = timeframe.change('M')
// forex_n_cdf  = syminfo.type == 'forex' or syminfo.type == 'cfd'
forex_n_cdf = true
tfMultiplier = timeframe.multiplier

if barstate.isfirst 
    // Forex Markets and UTC Zones
    array.push(a_majorCity, 'NEW YORK' ), array.push(a_utcTimeOffset, -5), array.push(a_utcCity, '(UTC-05:00) NEW YORK' )
    array.push(a_majorCity, 'LONDON'   ), array.push(a_utcTimeOffset, 0 ), array.push(a_utcCity, '(UTC+00:00) LONDON'   )
    array.push(a_majorCity, 'FRANKFURT'), array.push(a_utcTimeOffset, 1 ), array.push(a_utcCity, '(UTC+01:00) FRANKFURT')
    array.push(a_majorCity, 'TOKYO'    ), array.push(a_utcTimeOffset, 9 ), array.push(a_utcCity, '(UTC+09:00) TOKYO'    )
    array.push(a_majorCity, 'SYDNEY'   ), array.push(a_utcTimeOffset, 10), array.push(a_utcCity, '(UTC+10:00) SYDNEY'   )

    // Forex Market Open/Close Hours
    array.push(a_forexMarket, '(UTC+10:00) SYDNEY'   ), array.push(a_forexOpenH, 07), array.push(a_forexCloseH, 16)
    array.push(a_forexMarket, '(UTC+09:00) TOKYO'    ), array.push(a_forexOpenH, 09), array.push(a_forexCloseH, 18)
    array.push(a_forexMarket, '(UTC+01:00) FRANKFURT'), array.push(a_forexOpenH, 08), array.push(a_forexCloseH, 16)
    array.push(a_forexMarket, '(UTC+00:00) LONDON'   ), array.push(a_forexOpenH, 08), array.push(a_forexCloseH, 17)
    array.push(a_forexMarket, '(UTC-05:00) NEW YORK' ), array.push(a_forexOpenH, 08), array.push(a_forexCloseH, 17)

    // Tyipically Traded Volume and Forex Market Events 
    array.push(a_tradingVolume, 1   ) , array.push(a_forexEvents, 'Lowest \n - New York, Chicago and Troronto Closed' ) //00
    array.push(a_tradingVolume, 1   ) , array.push(a_forexEvents, 'Lowest' ) //01
    array.push(a_tradingVolume, 1.7 ) , array.push(a_forexEvents, 'Low \n - Tokyo Open' ) //02
    array.push(a_tradingVolume, 2.8 ) , array.push(a_forexEvents, 'Low and Slightly Increasing \n - Hong Kong, Shanghai and Singapore Open' ) //03
    array.push(a_tradingVolume, 3   ) , array.push(a_forexEvents, 'Low' ) //04
    array.push(a_tradingVolume, 2   ) , array.push(a_forexEvents, 'Low and Decreasing' ) //05
    array.push(a_tradingVolume, 1.8 ) , array.push(a_forexEvents, 'Low \n - Dubai Open, Wellington Closed' ) //06
    array.push(a_tradingVolume, 2.3 ) , array.push(a_forexEvents, 'Low and Increasing\n - Moscow Open' ) //07
    array.push(a_tradingVolume, 3   ) , array.push(a_forexEvents, 'Low and Increasing\n - Johannesburg Open, Sydney Closed' ) //08
    array.push(a_tradingVolume, 4.5 ) , array.push(a_forexEvents, 'Medium \n - Frankfurt Open' ) // 09
    array.push(a_tradingVolume, 5.7 ) , array.push(a_forexEvents, 'High and Increasing \n - London, Zurich and Paris Open' ) // 10
    array.push(a_tradingVolume, 6   ) , array.push(a_forexEvents, 'High \n - Tokyo, Hong Kong, Shanghai and Singapore Closed' ) // 11
    array.push(a_tradingVolume, 5.3 ) , array.push(a_forexEvents, 'High \n - Dubai Closed' ) // 12
    array.push(a_tradingVolume, 4.8 ) , array.push(a_forexEvents, 'High \n - India closes in 30 mins' ) // 13
    array.push(a_tradingVolume, 5.1 ) , array.push(a_forexEvents, 'High and Increasing \n - India Closed (30 mins ago)' ) // 14
    array.push(a_tradingVolume, 6.8 ) , array.push(a_forexEvents, 'Higher \n - New York and Toronto Open' ) // 15
    array.push(a_tradingVolume, 8.1 ) , array.push(a_forexEvents, 'Higher \n - Chicago Open, Frankfurt Closed' ) // 16
    array.push(a_tradingVolume, 9   ) , array.push(a_forexEvents, 'Highest \n - Johannesburg Closed' ) // 17
    array.push(a_tradingVolume, 7.8 ) , array.push(a_forexEvents, 'Higher and Decreasing \n - London and Moscow Closed' ) // 18
    array.push(a_tradingVolume, 5.3 ) , array.push(a_forexEvents, 'Medium and Decreasing' ) // 19
    array.push(a_tradingVolume, 3.1 ) , array.push(a_forexEvents, 'Low and Decreasing' ) // 20
    array.push(a_tradingVolume, 2   ) , array.push(a_forexEvents, 'Low and Decreasing \n - Wellington Open' ) // 21
    array.push(a_tradingVolume, 1.3 ) , array.push(a_forexEvents, 'Low and Decreasing' ) // 22
    array.push(a_tradingVolume, 1   ) , array.push(a_forexEvents, 'Lowest \n - Sydney Open' ) // 23
    array.push(a_tradingVolume, 1 ) // Dummy required for Trading Volume display

// ---------------------------------------------------------------------------------------------- //
// Forex Market Sessions Tabular View ----------------------------------------------------------- //

f_whatIsTheTime(_utc, _dst) =>
    TZ = 'Etc/UTC'
    DST = _dst ? 1 : 0
    utcTime = (array.get(a_utcTimeOffset, array.indexof(a_utcCity, _utc)) + DST) * 3600000 + timenow
    [math.floor(utcTime / 3600000) % 24, math.floor(utcTime / 60000) % 60, math.floor(utcTime / 1000) % 60, dayofmonth(int(utcTime), TZ), month(int(utcTime), TZ), year(int(utcTime), TZ), dayofweek(int(utcTime), TZ)]

f_digitalDisplay(_utc, _marketDetails, _dst) =>

    [h, m, s, D, M, Y, A] = f_whatIsTheTime(_utc, _dst)

    ht = h < 10 ? '0' + str.tostring(h) : str.tostring(h)
    mt = m < 10 ? '0' + str.tostring(m) : str.tostring(m)
    st = s < 10 ? '0' + str.tostring(s) : str.tostring(s)
    Dt = D < 10 ? '0' + str.tostring(D) : str.tostring(D)
    Mt = M < 10 ? '0' + str.tostring(M) : str.tostring(M)
    Yt = str.tostring(Y)
    dateTime = Dt + '/' + Mt + '/' + Yt + '-' + ht + ':' + mt + ':' + st

    if _marketDetails
        if A != 1 and A != 7
            fxO = array.get(a_forexOpenH , array.indexof(a_forexMarket, _utc))
            fxC = array.get(a_forexCloseH, array.indexof(a_forexMarket, _utc))

            market = if h >= fxO and h < fxC
                hc = fxC - h - 1
                mc = 60 - m - 1
                sc = 60 - s
                sct = sc < 10 ? '0' + str.tostring(sc) : str.tostring(sc)
                mct = mc < 10 ? '0' + str.tostring(mc) : str.tostring(mc)
                hct = hc < 10 ? '0' + str.tostring(hc) : str.tostring(hc)
                closes = hct + ':' + mct + ':' + sct

                if hc == 0
                    sc % 2 ? dateTime + ' ðŸŸ¢ Closes in ' + closes : dateTime + ' ðŸ”´ Closes in ' + closes
                else
                    dateTime + ' ðŸŸ¢ Closes in ' + closes
            else
                ho = if h < fxO
                    fxO - h - 1
                else
                    24 - h + fxO - 1
                mo = 60 - m - 1
                so = 60 - s
                sot = so < 10 ? '0' + str.tostring(so) : str.tostring(so)
                mot = mo < 10 ? '0' + str.tostring(mo) : str.tostring(mo)
                hot = ho < 10 ? '0' + str.tostring(ho) : str.tostring(ho)
                opens = hot + ':' + mot + ':' + sot

                if h >= fxC and A == 6
                    dateTime + ' ðŸŸ  Weekend'
                else
                    if ho == 0
                        so % 2 ? dateTime + ' ðŸ”´ Opens in ' + opens : dateTime + ' ðŸŸ¢ Opens in ' + opens
                    else
                        dateTime + ' ðŸ”´ Opens in ' + opens
            market
        else
            dateTime + ' ðŸŸ  Weekend'
    else
        dateTime

statPosition = switch statPos
    'Top Left'      => position.top_left
    'Top Center'    => position.top_center
    'Top Right'     => position.top_right
    'Middle Right'  => position.middle_right
    'Bottom Left'   => position.bottom_left
    'Bottom Center' => position.bottom_center

var table clock = table.new(statPosition, 3, 5, border_width = 3)

hide = hideIfNot ? forex_n_cdf ? true : false : true

if barstate.islast and i_forex and hide
    market = f_digitalDisplay('(UTC+10:00) SYDNEY', true, i_sydneySummerTime )
    marketColor = str.contains(market, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 0, "â–ˆ", text_size = textSize2, text_color = cSydney)
    table.cell(clock, 1, 0, array.get(a_majorCity, array.indexof(a_utcCity, '(UTC+10:00) SYDNEY'))    , text_color = color.blue, bgcolor = color.new(color.blue,  75), text_halign = text.align_left, text_size = textSize2)
    table.cell(clock, 2, 0, market                                                                    , text_color = marketColor , bgcolor =   color.new(marketColor, 75), text_halign = text.align_left, text_size = textSize2)

    market := f_digitalDisplay('(UTC+09:00) TOKYO', true , false)
    marketColor := str.contains(market, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 1, "â–ˆ", text_size = textSize2, text_color = cTokyo)
    table.cell(clock, 1, 1, array.get(a_majorCity, array.indexof(a_utcCity, '(UTC+09:00) TOKYO'))     , text_color = color.blue, bgcolor = color.new(color.blue,  75), text_halign = text.align_left, text_size = textSize2)
    table.cell(clock, 2, 1, market                                                                    , text_color = marketColor , bgcolor =   color.new(marketColor, 75), text_halign = text.align_left, text_size = textSize2)

    market := f_digitalDisplay('(UTC+01:00) FRANKFURT', true , i_frankfurtSummerTime)
    marketColor := str.contains(market, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 2, "â–ˆ", text_size = textSize2, text_color = cFrankfurt)
    table.cell(clock, 1, 2, array.get(a_majorCity, array.indexof(a_utcCity, '(UTC+01:00) FRANKFURT')) , text_color = color.blue, bgcolor = color.new(color.blue,  75), text_halign = text.align_left, text_size = textSize2)
    table.cell(clock, 2, 2, market                                                                    , text_color = marketColor , bgcolor =   color.new(marketColor, 75), text_halign = text.align_left, text_size = textSize2)

    market := f_digitalDisplay('(UTC+00:00) LONDON'  , true , i_londonSummerTime )
    marketColor := str.contains(market, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 3, "â–ˆ", text_size = textSize2, text_color = cLondon)
    table.cell(clock, 1, 3, array.get(a_majorCity, array.indexof(a_utcCity, '(UTC+00:00) LONDON'))    , text_color = color.blue, bgcolor = color.new(color.blue,  75), text_halign = text.align_left, text_size = textSize2)
    table.cell(clock, 2, 3, market                                                                    , text_color = marketColor , bgcolor =   color.new(marketColor, 75), text_halign = text.align_left, text_size = textSize2)

    market :=  f_digitalDisplay('(UTC-05:00) NEW YORK', true , i_newyorkSummerTime)
    marketColor := str.contains(market, 'Closes') ? #26a69a : #ef5350
    table.cell(clock, 0, 4, "â–ˆ", text_size = textSize2, text_color = cNYork)
    table.cell(clock, 1, 4, array.get(a_majorCity, array.indexof(a_utcCity, '(UTC-05:00) NEW YORK'))  , text_color = color.blue, bgcolor = color.new(color.blue,  75), text_halign = text.align_left, text_size = textSize2)
    table.cell(clock, 2, 4, market                                                                    , text_color = marketColor , bgcolor =   color.new(marketColor, 75), text_halign = text.align_left, text_size = textSize2)

// ---------------------------------------------------------------------------------------------- //
// Forex Market Events -------------------------------------------------------------------------- //

var blabla       = 0
var label events = na

var a_lines      = array.new_line()
var a_labels     = array.new_label()
var a_fill       = array.new_linefill()

lookbackLength   = 1440 / tfMultiplier
priceHighest     = ta.highest(high, lookbackLength)
priceLowest      = ta.lowest (low , lookbackLength)
priceChangeRate  = (priceHighest - priceLowest) / priceHighest
priceLowest     := priceLowest  * (1 - priceChangeRate * oscVerticalOffset)
oscHighest       = 10 //ta.highest(osc, lookbackLength)
hight            = priceChangeRate / oscHight

if dayChange and tfMultiplier <= 60 and forex_n_cdf and forexEvents and timeframe.isintraday
    if array.size(a_lines) > 0
        for i = 1 to array.size(a_lines)
            line.delete(array.shift(a_lines))

    if array.size(a_labels) > 0
        for i = 1 to array.size(a_labels)
            label.delete(array.shift(a_labels))

    if array.size(a_fill) > 0
        for i = 1 to array.size(a_fill)
            linefill.delete(array.shift(a_fill))
    
    for barIndex = 0 to 23
        array.push(a_lines, line.new(bar_index +  barIndex      * 60 / tfMultiplier, priceLowest * (1 - (oscHighest - array.get(a_tradingVolume, barIndex)    ) *  hight / oscHighest), 
                                     bar_index + (barIndex + 1) * 60 / tfMultiplier, priceLowest * (1 - (oscHighest - array.get(a_tradingVolume, barIndex + 1)) *  hight / oscHighest), xloc.bar_index, extend.none,  #00000000, line.style_solid, 1)) // color.from_gradient(array.get(a_tradingVolume, barIndex), 1,  6, #ef5350, #26a69a), line.style_solid, 1)) // 

        array.push(a_lines, line.new(bar_index +  barIndex      * 60 / tfMultiplier, priceLowest * (1 - hight), 
                                     bar_index + (barIndex + 1) * 60 / tfMultiplier, priceLowest * (1 - hight), xloc.bar_index, extend.none, #00000000, line.style_solid, 1))

        array.push(a_fill, linefill.new(array.get(a_lines, 2 * barIndex), array.get(a_lines, 2 * barIndex + 1), color.new(color.from_gradient(array.get(a_tradingVolume, barIndex), 1,  6, #ef5350, #26a69a), 85) ))

        array.push(a_labels, label.new(bar_index + barIndex    * 60 / tfMultiplier,  priceLowest * (1 - (oscHighest - array.get(a_tradingVolume, barIndex)) *  hight / oscHighest), '', xloc.bar_index, yloc.price, #00000000, label.style_circle, #00000000, size.tiny, text.align_left, 'At this time of day\n - Trading volume is typically ' + array.get(a_forexEvents, barIndex) )  )
        array.push(a_labels, label.new(bar_index + barIndex    * 60 / tfMultiplier,  priceLowest * (1 - (oscHighest - array.get(a_tradingVolume, barIndex)) *  hight / oscHighest), '', xloc.bar_index, yloc.price, color.from_gradient(array.get(a_tradingVolume, barIndex), 1,  6, #ef5350, #26a69a), label.style_circle, #00000000, size.auto, text.align_left, '')  )//'At this time of day\n - Trading volume is typically ' + array.get(a_forexEvents, barIndex) )  )
    array.push(a_labels, label.new(bar_index + 24    * 60 / tfMultiplier,  priceLowest * (1 - (oscHighest - array.get(a_tradingVolume, 0)) *  hight / oscHighest), '', xloc.bar_index, yloc.price, #00000000, label.style_circle, #00000000, size.tiny, text.align_left, 'At this time of day\n - Trading volume is typically ' + array.get(a_forexEvents, 0) )  )
    array.push(a_labels, label.new(bar_index + 24    * 60 / tfMultiplier,  priceLowest * (1 - (oscHighest - array.get(a_tradingVolume, 0)) *  hight / oscHighest), '', xloc.bar_index, yloc.price, color.from_gradient(array.get(a_tradingVolume, 0), 1,  6, #ef5350, #26a69a), label.style_circle, #00000000, size.auto, text.align_left, '')  )//'At this time of day\n - Trading volume is typically ' + array.get(a_forexEvents, 0) )  )

    label.delete(events[1]) 
    blabla := 0
    events := label.new(bar_index,  priceLowest * (1 - hight), '', xloc.bar_index, yloc.price, color.new(color.from_gradient(array.get(a_tradingVolume, blabla), 1,  6, #ef5350, #26a69a), 75), label.style_label_up, color.white, size.tiny, text.align_left, 'At this time of day\n - Trading volume is typically ' + array.get(a_forexEvents, blabla) )
    
if ta.change(priceLowest) < 0 and not dayChange and tfMultiplier <= 60 and forex_n_cdf and forexEvents and timeframe.isintraday
    for barIndex = 0 to array.size(a_lines) - 1
        line.set_y1(array.get(a_lines , barIndex), line.get_y1(array.get(a_lines , barIndex)) - priceLowest[1] + priceLowest)
        line.set_y2(array.get(a_lines , barIndex), line.get_y2(array.get(a_lines , barIndex)) - priceLowest[1] + priceLowest)
    for barIndex = 0 to array.size(a_labels) - 1
        label.set_y(array.get(a_labels, barIndex), label.get_y(array.get(a_labels, barIndex)) - priceLowest[1] + priceLowest)
    label.set_y(events, label.get_y(events) - priceLowest[1] + priceLowest)

if ta.change(time('60')) and not dayChange and tfMultiplier <= 60 and forex_n_cdf and forexEvents and timeframe.isintraday
    blabla += 1
    label.set_tooltip(events, 'At this time of day\n - Trading volume is typically ' + array.get(a_forexEvents, blabla) )
    label.set_color(events, color.from_gradient(array.get(a_tradingVolume, blabla), 1,  6, #ef5350, #26a69a))
    label.set_x(events, bar_index) 
else if forex_n_cdf and tfMultiplier <= 60 and forexEvents and timeframe.isintraday
    label.set_x(events, bar_index)

// ---------------------------------------------------------------------------------------------- //
// Process Forex Markets ------------------------------------------------------------------------ //

f_getSessionInfo(_utc, _dst) =>
    TZ  = 'Etc/UTC'
    DST = _dst ? 1 : 0
    utcTime = (array.get(a_utcTimeOffset, array.indexof(a_utcCity, _utc)) + DST) * 3600000 + time
    h = math.floor(utcTime / 3600000) % 24
    A = dayofweek(int(utcTime), TZ)

    if A != 1 and A != 7
        fxO = array.get(a_forexOpenH , array.indexof(a_forexMarket, _utc))
        fxC = array.get(a_forexCloseH, array.indexof(a_forexMarket, _utc))

        if h >= fxO and h < fxC
            true
        else
            false
    else
        false

f_calculateOpeningRange(_numberOfDataRequired) =>
    var orH = 0., var orL = 0.
    [aH, aL] = request.security_lower_tf(syminfo.tickerid, '1', [high, low])
    //f_drawLabelX(bar_index, high, str.tostring(aH, format.mintick), xloc.bar_index, yloc.price, color.gray, label.style_label_down, color.white, size.normal, text.align_left, str.tostring(array.size(aH)))
    //f_drawLabelX(bar_index, low , str.tostring(aL, format.mintick), xloc.bar_index, yloc.price, color.gray, label.style_label_up  , color.white, size.normal, text.align_left, str.tostring(low , format.mintick))

    if array.size(aH) > 0
        if _numberOfDataRequired >= tfMultiplier 
            orH := array.max(aH)
            orL := array.min(aL)

        else if _numberOfDataRequired < tfMultiplier
            if array.size(aH) >= _numberOfDataRequired
                orH := array.get(aH, 0)
                orL := array.get(aL, 0)

                for c = 1 to _numberOfDataRequired - 1
                    orH := math.max(array.get(aH, c), orH)
                    orL := math.min(array.get(aL, c), orL)
            else 
                orH := array.max(aH)
                orL := array.min(aL)
    [orH, orL]

f_processForex(_show, _utc, _dst, _color, _bg) =>
    if _show != 'None' 
        var pro = 0., var prh = 0., var prl = 0.
        var sessionStartBar = 0
        var line lnh = na, var line lnl = na
        var count = 0

        session = f_getSessionInfo(_utc, _dst)
        
        if session and session != session[1] 
            sessionStartBar := bar_index
            sessionEndbar    = sessionStartBar + int( ( array.get(a_forexCloseH, array.indexof(a_utcCity, _utc)) - array.get(a_forexOpenH, array.indexof(a_utcCity, _utc)) ) * 60 ) / tfMultiplier

            if _show == 'Open'
                pro := open
                line.new(sessionStartBar, pro, sessionEndbar, pro, xloc.bar_index, extend.none, _color, line.style_solid, 2)

            if _show == 'Range'
                prh := high
                prl := low
                lnh := line.new(sessionStartBar, prh , sessionEndbar, prh , xloc.bar_index, extend.none, _color, line.style_solid, 1)
                lnl := line.new(sessionStartBar, prl , sessionEndbar, prl , xloc.bar_index, extend.none, _color, line.style_solid, 1)
                
            if _show == '5m Opening Range'
                [prh5, prl5] = f_calculateOpeningRange(5)
                lnh := line.new(sessionStartBar, prh5, sessionEndbar, prh5, xloc.bar_index, extend.none, _color, line.style_solid, 1)
                lnl := line.new(sessionStartBar, prl5, sessionEndbar, prl5, xloc.bar_index, extend.none, _color, line.style_solid, 1)

            if _show == '15m Opening Range'
                [prh5, prl5] = f_calculateOpeningRange(15)
                lnh := line.new(sessionStartBar, prh5, sessionEndbar, prh5, xloc.bar_index, extend.none, _color, line.style_solid, 1)
                lnl := line.new(sessionStartBar, prl5, sessionEndbar, prl5, xloc.bar_index, extend.none, _color, line.style_solid, 1)

            if _bg
                linefill.new(lnh, lnl, color.new(_color, 89))

            if _show == 'Channel'
                [prh60, prl60] = f_calculateOpeningRange(60)
                lnh := line.new(sessionStartBar, prh60, sessionStartBar + (_utc == '(UTC+01:00) FRANKFURT' ? 900 : 1320) / tfMultiplier, prh60, xloc.bar_index, extend.none, _color, line.style_solid, 1)
                lnl := line.new(sessionStartBar, prl60, sessionStartBar + (_utc == '(UTC+01:00) FRANKFURT' ? 900 : 1320) / tfMultiplier, prl60, xloc.bar_index, extend.none, _color, line.style_solid, 1)

                linefill.new(lnh, lnl, color.new(_color, 89))

            if (count == 5 / tfMultiplier and _show == '5m Opening Range') or (count == 15 / tfMultiplier and _show == '15m Opening Range') or (count == 60 / tfMultiplier and _show == 'Channel')
                count := 0
                
        if session
            if _show == 'Range'
                line.set_y1(lnh, math.max(high, line.get_y1(lnh))), line.set_y2(lnh, math.max(high, line.get_y2(lnh)))
                line.set_y1(lnl, math.min(low , line.get_y1(lnl))), line.set_y2(lnl, math.min(low , line.get_y2(lnl)))
            
            if (_show == '5m Opening Range' and count < 5 / tfMultiplier and tfMultiplier < 5) or (_show == '15m Opening Range' and count < 15 / tfMultiplier and tfMultiplier < 15) or (_show == 'Channel' and count < 60 / tfMultiplier and tfMultiplier < 60)
                line.set_y1(lnh, math.max(high, line.get_y1(lnh))), line.set_y2(lnh, math.max(high, line.get_y2(lnh)))
                line.set_y1(lnl, math.min(low , line.get_y1(lnl))), line.set_y2(lnl, math.min(low , line.get_y2(lnl)))
                count += 1

if timeframe.isintraday and forex_n_cdf
    f_processForex(openingChannel != 'None' ? 'Channel' : 'None', openingChannel == 'European Session' ? '(UTC+01:00) FRANKFURT' : '(UTC+09:00) TOKYO', openingChannel == 'European Session' ? i_frankfurtSummerTime : false, cChannel, true)
    f_processForex(openingChannel == 'Both' ? 'Channel' : 'None', '(UTC+01:00) FRANKFURT', i_frankfurtSummerTime, cChannel, true)

    f_processForex(shSydney   , '(UTC+10:00) SYDNEY'   , i_sydneySummerTime   , cSydney   , bgSydney   )
    f_processForex(shTokyo    , '(UTC+09:00) TOKYO'    , false                , cTokyo    , bgTokyo    )
    f_processForex(shFrankfurt, '(UTC+01:00) FRANKFURT', i_frankfurtSummerTime, cFrankfurt, bgFrankfurt)
    f_processForex(shLondon   , '(UTC+00:00) LONDON'   , i_londonSummerTime   , cLondon   , bgLondon   )
    f_processForex(shNYork    , '(UTC-05:00) NEW YORK' , i_newyorkSummerTime  , cNYork    , bgNYork    )

// ---------------------------------------------------------------------------------------------- //
// Day Open

var dayHistoryBar = 0
var dayStartBar   = 0
var line  lnhd = na, var line  lnld = na
var label lbhd = na, var label lbld = na
var countd = 0

atrRange = f_getATR(dayATRLength, 'D') 
[H1, L1] = f_calculatePreviousRange('D')

if dayChange and  (dayOpen != 'None' or dayRefLevels != 'None') and timeframe.isintraday
    dayHistoryBar := nz(dayStartBar) ? dayStartBar : bar_index
    dayStartBar   := bar_index
    dayEndBar      = 2 * dayStartBar - dayHistoryBar
    O0 = open

    if dayOpen == 'Open'
        f_drawOnlyLineX(bar_index, O0, dayEndBar, open, xloc.bar_index, extend.none, dayColor, line.style_solid, 1)
        f_drawLabelX(dayEndBar, O0, 'DO - ' + str.tostring(O0, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, dayColor, size.normal, text.align_left, '')
        //f_drawOnlyLineX(bar_index, open, dayEndBar, open, xloc.bar_index, extend.none, color.aqua, line.style_solid, 1)
        //f_drawLabelX(dayEndBar, open, 'DO - ' + str.tostring(open, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, color.aqua, size.normal, text.align_left, '')

    if dayOpen == '15m Opening Range'
        [prh, prl] = f_calculateOpeningRange(15)
        lnhd := line.new(dayStartBar, prh, dayEndBar, prh, xloc.bar_index, extend.none, dayColor, line.style_solid, 1)
        lnld := line.new(dayStartBar, prl, dayEndBar, prl, xloc.bar_index, extend.none, dayColor, line.style_solid, 1)

        linefill.new(lnhd, lnld, color.new(dayColor, 89))

    if dayOpen == '5m Opening Range'
        [prh, prl] = f_calculateOpeningRange(5)
        lnhd := line.new(dayStartBar, prh, dayEndBar, prh, xloc.bar_index, extend.none, dayColor, line.style_solid, 1)
        lnld := line.new(dayStartBar, prl, dayEndBar, prl, xloc.bar_index, extend.none, dayColor, line.style_solid, 1)

        linefill.new(lnhd, lnld, color.new(dayColor, 89))

    if dayOpen == 'First Hour Opening Range'
        [prh, prl] = f_calculateOpeningRange(60)
        lnhd := line.new(dayStartBar, prh, dayEndBar, prh, xloc.bar_index, extend.none, dayColor, line.style_solid, 1)
        lnld := line.new(dayStartBar, prl, dayEndBar, prl, xloc.bar_index, extend.none, dayColor, line.style_solid, 1)
        //label.delete(lbhd[1]), label.delete(lbld[1])
        //lbhd := label.new(dayEndBar, prh60, 'DORH - ' + str.tostring(open, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, color.aqua, size.normal, text.align_left, '')
        //lbld := label.new(dayEndBar, prl60, 'DORL - ' + str.tostring(open, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, color.aqua, size.normal, text.align_left, '')

        linefill.new(lnhd, lnld, color.new(dayColor, 89))
    
    if (countd == 60 / tfMultiplier and dayOpen == 'First Hour Opening Range') or (countd == 15 / tfMultiplier and dayOpen == '15m Opening Range') or (countd == 5 / tfMultiplier and dayOpen == '5m Opening Range')
        countd := 0

    if dayRefLevels != 'None'
        litStat = '\n\nAverage True Range = ' + str.tostring(atrRange, format.mintick) + 
                  '\nPrevious Day Range = '   + str.tostring(H1 - L1 , format.mintick) +
                  '\n   -Previous Day High = '  + str.tostring(H1, format.mintick) +
                  '\n   -Previous Day Low  = '  + str.tostring(L1, format.mintick)

        rangee = dayRefLevels == 'Average True Range (ATR)' ? atrRange : H1 - L1

        f_drawLineX (dayStartBar, O0 + rangee * dayRefLevel1, dayEndBar, O0 + rangee * dayRefLevel1, xloc.bar_index, extend.none, dayRefColor, line.style_dotted,  2)
        f_drawLabelX(dayEndBar  , O0 + rangee * dayRefLevel1, 'R1 - ' + str.tostring(O0 + rangee * dayRefLevel1, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, dayRefColor, size.normal, text.align_left, 'First Reference Level : '  + str.tostring(O0 + rangee * dayRefLevel1, format.mintick) + litStat)

        f_drawLineX (dayStartBar, O0 - rangee * dayRefLevel1, dayEndBar, O0 - rangee * dayRefLevel1, xloc.bar_index, extend.none, dayRefColor, line.style_dotted,  2)
        f_drawLabelX(dayEndBar  , O0 - rangee * dayRefLevel1, 'S1 - ' + str.tostring(O0 - rangee * dayRefLevel1, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, dayRefColor, size.normal, text.align_left, 'First Reference Level : '  + str.tostring(O0 - rangee * dayRefLevel1, format.mintick) + litStat)

        if dayRefLevel2 > dayRefLevel1
            f_drawLineX (dayStartBar, O0 + rangee * dayRefLevel2, dayEndBar, O0 + rangee * dayRefLevel2, xloc.bar_index, extend.none, dayRefColor, line.style_dotted,  2)
            f_drawLabelX(dayEndBar  , O0 + rangee * dayRefLevel2, 'R2 - ' + str.tostring(O0 + rangee * dayRefLevel2, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, dayRefColor, size.normal, text.align_left, 'Second Reference Level : ' + str.tostring(O0 + rangee * dayRefLevel2, format.mintick) + litStat)

            f_drawLineX (dayStartBar, O0 - rangee * dayRefLevel2, dayEndBar, O0 - rangee * dayRefLevel2, xloc.bar_index, extend.none, dayRefColor, line.style_dotted,  2)
            f_drawLabelX(dayEndBar  , O0 - rangee * dayRefLevel2, 'S2 - ' + str.tostring(O0 - rangee * dayRefLevel2, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, dayRefColor, size.normal, text.align_left, 'Second Reference Level : ' + str.tostring(O0 - rangee * dayRefLevel2, format.mintick) + litStat)


if not dayChange and timeframe.isintraday and (dayOpen == 'First Hour Opening Range' and countd < 60 / tfMultiplier and tfMultiplier < 60)  or (dayOpen == '15m Opening Range' and countd < 15 / tfMultiplier and tfMultiplier < 15) or (dayOpen == '5m Opening Range' and countd < 5 / tfMultiplier and tfMultiplier < 5)
    line.set_y1(lnhd, math.max(high, line.get_y1(lnhd))), line.set_y2(lnhd, math.max(high, line.get_y2(lnhd)))
    line.set_y1(lnld, math.min(low , line.get_y1(lnld))), line.set_y2(lnld, math.min(low , line.get_y2(lnld)))
    label.set_y(lbhd, math.max(high, line.get_y1(lnhd))), label.set_y(lbld, math.min(low , line.get_y2(lnld)))
    countd += 1

// ---------------------------------------------------------------------------------------------- //
// Week - Month Open

var line  lnow = na, var label lbow = na

if weekOpen
    if weekChange
        line.delete(lnow[1]), label.delete(lbow[1])
        lnow := line.new(bar_index, open, last_bar_index + 3, open, xloc.bar_index, extend.none, weekColor, line.style_solid, 1)
        lbow := label.new(last_bar_index + 3, open, 'WO - ' + str.tostring(open, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, weekColor, size.normal, text.align_left, '')
    else
        line.set_x2(lnow, last_bar_index + 3), label.set_x(lbow, last_bar_index + 3)

var line  lnom = na, var label lbom = na

if monthOpen
    if monthChange
        line.delete(lnom[1]), label.delete(lbom[1])
        lnom := line.new(bar_index, open, last_bar_index + 3, open, xloc.bar_index, extend.none, monthColor, line.style_solid, 1)
        lbom := label.new(last_bar_index + 3, open, 'MO - ' + str.tostring(open, format.mintick), xloc.bar_index, yloc.price, #00000000, label.style_label_left, monthColor, size.normal, text.align_left, '')
    else
        line.set_x2(lnom, last_bar_index + 3), label.set_x(lbom, last_bar_index + 3)

// ---------------------------------------------------------------------------------------------- //
// VWAP ----------------------------------------------------------------------------------------- //

autoAnchor = timeframe.change(vwapAnchor)
interAnchor = startDate == time
anchor = htf_tf == 'Interactive' ? interAnchor : autoAnchor
[vwap, upper, lower] = ta.vwap(vwapSource, anchor, stdevMult1)

plot(isVwap  ? vwap : na, 'VWAP Line',  anchor ? na : #0496ff)
pu1 = plot(isVwap  and vwapBand1 ? upper : na, 'VWAP Bands Upper #1', anchor ? na : #4caf50)
pl1 = plot(isVwap  and vwapBand1 ? lower : na, 'VWAP Bands Lower #1', anchor ? na : #4caf50)
fill(pu1, pl1, title="VWAP Bands Fill #1", color= isVwap  and vwapBand1 ? color.new(color.green, 95)  : na)

pu2 = plot(isVwap  and vwapBand2 ? vwap + (upper - vwap)/stdevMult1 * stdevMult2 : na, 'VWAP Bands Upper #2', anchor ? na : #808000)
pl2 = plot(isVwap  and vwapBand2 ? vwap - (vwap - lower)/stdevMult1 * stdevMult2 : na, 'VWAP Bands Lower #2', anchor ? na : #808000)
fill(pu2, pl2, title="VWAP Bands Fill #2", color= isVwap  and vwapBand2 ? color.new(color.olive, 95) : na)

//plot(isVwap  and vwapBand3 ? vwap + (upper - vwap)/stdevMult1 * stdevMult3 : na, '', anchor ? na : #00897b)
//plot(isVwap  and vwapBand3 ? vwap - (vwap - lower)/stdevMult1 * stdevMult3 : na, '', anchor ? na : #00897b)

// // ---------------------------------------------------------------------------------------------- //
// // Pivot Points High Low ------------------------------------------------------------------------ //

// nzVolume          = nz(volume)
// pvtHigh           = ta.pivothigh(pvtLength, pvtLength)
// pvtLow            = ta.pivotlow (pvtLength, pvtLength)
// proceed           = not na(pvtHigh) or not na(pvtLow)

// pvtLengthTemp     = 3
// pvtHighTemp       = ta.pivothigh(pvtLengthTemp, pvtLengthTemp)
// pvtLowTemp        = ta.pivotlow (pvtLengthTemp, pvtLengthTemp)
// proceedTemp       = not na(pvtHighTemp) or not na(pvtLowTemp)

// var x1            = 0
// var x2            = 0
// var x2Temp        = 0

// var pvtHigh1      = 0.
// var pvtLow1       = 0.
// var pvtHigh1Temp  = 0.
// var pvtLow1Temp   = 0.

// //var pvtLast       = ''

// if proceed
//     x1 := x2
//     x2 := bar_index

// if proceedTemp
//     x2Temp := bar_index

// profileLength = x2 - x1
// profileLengthTemp = x2Temp - pvtLengthTemp - x2 + pvtLength

// var label tempHigh = na
// var label tempLow  = na

// if dispPVT
//     if not na(pvtHigh)
//         tradedVolume = f_getTradedVolume(profileLength, proceed, pvtLength)
//         f_drawOnlyLabelX(bar_index[pvtLength], pvtHigh, (pvtPrice ? str.tostring(pvtHigh, format.mintick) :  '') + (pvtChange ? (pvtPrice ? ' â†‘ %' : 'â†‘ %') + str.tostring((pvtHigh - pvtLow1) * 100 / pvtLow1 , '#.##') : '') + (pvtVolume and  nzVolume ? (pvtPrice or pvtChange ? '\n' : '') + str.tostring(tradedVolume, format.volume) : ''), xloc.bar_index, yloc.price, chart.fg_color, label.style_label_down, chart.bg_color, (not pvtPrice and not pvtChange and not pvtVolume ? size.tiny : pvtTextSize), text.align_center, 'Pivot High : ' + str.tostring(pvtHigh, format.mintick) + '\n -Price Change : â†‘ %' + str.tostring((pvtHigh - pvtLow1) * 100 / pvtLow1 , '#.##') + (nzVolume ? '\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume)  + ' (' + str.tostring(profileLength - 1) + ' bars)\n  *Average Volume/Bar : ' + str.tostring(tradedVolume / (profileLength - 1), format.volume) : '') + '\n\nNumber of bars : ' + str.tostring(profileLength) )
//         pvtHigh1 := pvtHigh
//         //pvtLast  := 'H'
//         label.delete(tempHigh[1])
//         if x2 - pvtLength > x2Temp - pvtLengthTemp
//             label.delete(tempLow[1])

//     if not na(pvtLow)
//         tradedVolume = f_getTradedVolume(profileLength, proceed, pvtLength)
//         f_drawOnlyLabelX(bar_index[pvtLength], pvtLow , (pvtPrice ? str.tostring(pvtLow , format.mintick) :  '') + (pvtChange ? (pvtPrice ? ' â†“ %' : 'â†“ %') + str.tostring((pvtHigh1 - pvtLow) * 100 / pvtHigh1, '#.##') : '') + (pvtVolume and  nzVolume ? (pvtPrice or pvtChange ? '\n' : '') + str.tostring(tradedVolume, format.volume) : ''), xloc.bar_index, yloc.price, chart.fg_color, label.style_label_up  , chart.bg_color, (not pvtPrice and not pvtChange and not pvtVolume ? size.tiny : pvtTextSize), text.align_center, 'Pivot Low : '  + str.tostring(pvtLow , format.mintick) + '\n -Price Change : â†“ %' + str.tostring((pvtHigh1 - pvtLow) * 100 / pvtHigh1, '#.##') + (nzVolume ? '\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume) + ' (' + str.tostring(profileLength - 1) + ' bars)\n  *Average Volume/Bar : ' + str.tostring(tradedVolume / (profileLength - 1), format.volume) : '') + '\n\nNumber of bars : ' + str.tostring(profileLength) )
//         pvtLow1  := pvtLow
//         //pvtLast  := 'L'
//         label.delete(tempLow[1])
//         if x2 - pvtLength > x2Temp - pvtLengthTemp// ???
//             label.delete(tempHigh[1])

//     if not na(pvtHighTemp) //and pvtLast  == 'L' 
//         if pvtHighTemp > pvtHigh1Temp// or pvtHighTemp > pvtHigh1 
//             label.delete(tempHigh[1])
//             tradedVolume = f_getTradedVolume(profileLengthTemp, proceedTemp, pvtLengthTemp)
//             tempHigh := label.new(bar_index[pvtLengthTemp], pvtHighTemp, '* ' + (pvtPrice ? str.tostring(pvtHighTemp, format.mintick) :  '') + (pvtChange ? (pvtPrice ? ' â†‘ %' : 'â†‘ %') + str.tostring((pvtHighTemp - pvtLow1) * 100 / pvtLow1 , '#.##') : '') + (pvtVolume and  nzVolume ? (pvtPrice or pvtChange ? '\n' : '') + str.tostring(tradedVolume, format.volume) : ''), xloc.bar_index, yloc.price, #284aa9, label.style_label_down, color.white, (not pvtPrice and not pvtChange and not pvtVolume ? size.tiny : pvtTextSize), text.align_center, 'Temporary Pivot High : ' + str.tostring(pvtHighTemp, format.mintick) + '\n -Price Change : â†‘ %' + str.tostring((pvtHighTemp - pvtLow1) * 100 / pvtLow1 , '#.##') + (nzVolume ? '\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume)  + ' (' + str.tostring(profileLengthTemp - 1) + ' bars)\n  *Average Volume/Bar : ' + str.tostring(tradedVolume / (profileLengthTemp - 1), format.volume) : '') + '\n\nNumber of bars\n since last confirmed Pivot High/Low : ' + str.tostring(profileLengthTemp) + '\n\nWarning : subject to repaint, not a confirmed Pivot Level or Signal' )
//         pvtHigh1Temp := pvtHighTemp
    
//     if high > pvtHigh1Temp
//         label.delete(tempHigh[1])

//     if not na(pvtLowTemp) //and pvtLast  == 'H'
//         if pvtLowTemp < pvtLow1Temp// or pvtLowTemp < pvtLow1
//             tradedVolume = f_getTradedVolume(profileLengthTemp, proceedTemp, pvtLengthTemp)
//             label.delete(tempLow[1])
//             tempLow := label.new(bar_index[pvtLengthTemp], pvtLowTemp, '* ' + (pvtPrice ? str.tostring(pvtLowTemp, format.mintick) :  '') + (pvtChange ? (pvtPrice ? ' â†“ %' : 'â†“ %') + str.tostring((pvtHigh1 - pvtLowTemp) * 100 / pvtLowTemp , '#.##') : '') + (pvtVolume and  nzVolume ? (pvtPrice or pvtChange ? '\n' : '') + str.tostring(tradedVolume, format.volume) : ''), xloc.bar_index, yloc.price, #284aa9, label.style_label_up, color.white, (not pvtPrice and not pvtChange and not pvtVolume ? size.tiny : pvtTextSize), text.align_center, 'Temporary Pivot Low : ' + str.tostring(pvtLowTemp, format.mintick) + '\n -Price Change : â†“ %' + str.tostring((pvtHigh1 - pvtLowTemp) * 100 / pvtHigh1 , '#.##') + (nzVolume ? '\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume)  + ' (' + str.tostring(profileLengthTemp - 1) + ' bars)\n  *Average Volume/Bar : ' + str.tostring(tradedVolume / (profileLengthTemp - 1), format.volume) : '') + '\n\nNumber of bars\n since last confirmed Pivot High/Low : ' + str.tostring(profileLengthTemp) + '\n\nWarning : subject to repaint, not a confirmed Pivot Level or Signal')
//         pvtLow1Temp  := pvtLowTemp

//     if low < pvtLow1Temp
//         label.delete(tempLow[1])

// ---------------------------------------------------------------------------------------------- //
// Moving Average ------------------------------------------------------------------------------- //

plot(maDisplay ? f_getMA(maSource, maLength, maType) : na, 'Moving Average #1', maColor)
plot(maDisplay ? f_getMA(maSource2, maLength2, maType2) : na, 'Moving Average #2', maColor2, 2)
plot(maDisplay ? f_getMA(maSource3, maLength3, maType3) : na, 'Moving Average #3', maColor2, 2)


// ---------------------------------------------------------------------------------------------- //

var table logo = table.new(position.bottom_right, 1, 1)
if barstate.islast
    table.cell(logo, 0, 0, 'â˜¼â˜¾  ', text_size=size.normal, text_color=color.teal)


// Fractals
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© geneclash

showFractals = input(false,title="Show Fractals?",group="Fractals")
showBrekout = input(false,title="Show Market Structure Breakouts?",group="Fractals")
breakType = input.string("Body",title="Fractal Break Type:",options=["Wick+Body","Body"],group="Fractals")
n = input.int(title="Periods", defval=2, minval=2,group="Fractals") 
lineStyle= input.string(line.style_dotted,title="Line Style:",options=[line.style_dotted,line.style_dashed,line.style_solid],group="Fractals")
upClr = input.color(color.teal,title="Up/Down Line Colors:",inline="b_1",group="Fractals")
downClr = input.color(color.maroon,title="-",inline="b_1",group="Fractals") 

showImbalance = input(true,title="Show Breakout Imbalances",group="Imbalance")
showOtherImbalance = input(true,title="Show Other Imbalances",group="Imbalance")
hideFilled = input(false,title="Hide Filled Gaps",group="Imbalance")
imbGreenClr = input.color(color.new(color.green,65),title="Up:",inline="i_1",group="Imbalance")
imbRedClr = input.color(color.new(color.red,65),title="Down:",inline="i_1",group="Imbalance")
imbRestClr = input.color(color.new(color.yellow,65), title="Other:",inline="i_1",group="Imbalance")

showBoxes = input(false,title="Show OrderBlocks?",group="OrderBlock")
changeColor = input(false,title="Change OrderBlock Colors?",group="OrderBlock")
transGreenClr = input.color(color.new(color.green,80),title="Bg:",inline="a_1",group="OrderBlock")
greenClr = input.color(color.new(color.green,0),title="Border:",inline="a_1",group="OrderBlock")
transRedClr = input.color(color.new(color.red,80),title="Bg:",inline="b_1",group="OrderBlock")
redClr = input.color(color.new(color.red,0),title="Border:",inline="b_1",group="OrderBlock")

//Fractals{
// UpFractal
bool upflagDownFrontier = true
bool upflagUpFrontier0 = true
bool upflagUpFrontier1 = true
bool upflagUpFrontier2 = true
bool upflagUpFrontier3 = true
bool upflagUpFrontier4 = true

for i = 1 to n
    upflagDownFrontier := upflagDownFrontier and (high[n-i] < high[n])
    upflagUpFrontier0 := upflagUpFrontier0 and (high[n+i] < high[n])
    upflagUpFrontier1 := upflagUpFrontier1 and (high[n+1] <= high[n] and high[n+i + 1] < high[n])
    upflagUpFrontier2 := upflagUpFrontier2 and (high[n+1] <= high[n] and high[n+2] <= high[n] and high[n+i + 2] < high[n])
    upflagUpFrontier3 := upflagUpFrontier3 and (high[n+1] <= high[n] and high[n+2] <= high[n] and high[n+3] <= high[n] and high[n+i + 3] < high[n])
    upflagUpFrontier4 := upflagUpFrontier4 and (high[n+1] <= high[n] and high[n+2] <= high[n] and high[n+3] <= high[n] and high[n+4] <= high[n] and high[n+i + 4] < high[n])
flagUpFrontier = upflagUpFrontier0 or upflagUpFrontier1 or upflagUpFrontier2 or upflagUpFrontier3 or upflagUpFrontier4

upFractal = (upflagDownFrontier and flagUpFrontier)

//DownFractal
bool downflagDownFrontier = true
bool downflagUpFrontier0 = true
bool downflagUpFrontier1 = true
bool downflagUpFrontier2 = true
bool downflagUpFrontier3 = true
bool downflagUpFrontier4 = true

for i = 1 to n
    downflagDownFrontier := downflagDownFrontier and (low[n-i] > low[n])
    downflagUpFrontier0 := downflagUpFrontier0 and (low[n+i] > low[n])
    downflagUpFrontier1 := downflagUpFrontier1 and (low[n+1] >= low[n] and low[n+i + 1] > low[n])
    downflagUpFrontier2 := downflagUpFrontier2 and (low[n+1] >= low[n] and low[n+2] >= low[n] and low[n+i + 2] > low[n])
    downflagUpFrontier3 := downflagUpFrontier3 and (low[n+1] >= low[n] and low[n+2] >= low[n] and low[n+3] >= low[n] and low[n+i + 3] > low[n])
    downflagUpFrontier4 := downflagUpFrontier4 and (low[n+1] >= low[n] and low[n+2] >= low[n] and low[n+3] >= low[n] and low[n+4] >= low[n] and low[n+i + 4] > low[n])
flagDownFrontier = downflagUpFrontier0 or downflagUpFrontier1 or downflagUpFrontier2 or downflagUpFrontier3 or downflagUpFrontier4

downFractal = (downflagDownFrontier and flagDownFrontier)
//}

var float topValue = na, var float bottomValue = na
var int lastRedIndex = na, var float lastRedLow = na, var float lastRedHigh = na
var int lastGreenIndex = na, var float lastGreenLow = na, var float lastGreenHigh = na

var line topLine = na, var line bottomLine = na
var box demandBox = na, var box supplyBox = na

var box imbalanceBox = na
var bool checkUpImbalance = false
var bool checkDownImbalance = false

var topBreakBlock = false, var bottomBreakBlock = false
var isLongBreak = false, var isShortBreak = false
var arrBoxes = array.new_box(0)
var arrImbBoxes = array.new_box(0)

topBreakCheckSource = breakType == "Wick+Body" ? high : close
bottomBreakCheckSource = breakType == "Wick+Body" ? low : close

//IMBALANCE
//Data
L1Low = low
H3 = high[2]

H1High = high
L3 = low[2]


FVGUp = bool(H3 < L1Low ? 1 : 0)
plotFVGU = FVGUp ? H3 : na
plotFVGUL = FVGUp ? L1Low : na

FVGDown = L3 > H1 ? 1 : 0
plotFVGD = FVGDown ? L3 : na
plotFVGH = FVGDown ? H1 : na

if FVGUp and showOtherImbalance and checkUpImbalance == false
    imbalanceBox := box.new(bar_index-2, plotFVGU,bar_index,plotFVGUL, bgcolor=imbRestClr, border_color=imbRestClr)
    array.push(arrImbBoxes,imbalanceBox)    

if FVGDown and showOtherImbalance and checkDownImbalance == false
    imbalanceBox :=  box.new(bar_index-2, plotFVGH,bar_index,plotFVGD, bgcolor=imbRestClr, border_color=imbRestClr)
    array.push(arrImbBoxes,imbalanceBox)

//Last red check
if close < open
    lastRedIndex := bar_index
    lastRedLow := low
    lastRedHigh := high
    
//Last green check
if close > open
    lastGreenIndex := bar_index
    lastGreenLow := low
    lastGreenHigh := high

//Check Imbalance
if checkUpImbalance
    checkUpImbalance := false
    imbTop = low
    imbBottom = high[2]
    if imbTop > imbBottom and showImbalance 
        imbalanceBox := box.new(bar_index-2, imbTop,bar_index,imbBottom, bgcolor=imbGreenClr, border_color=imbGreenClr)
        array.push(arrImbBoxes,imbalanceBox)
        alert("Bullish Imbalance Detected!",freq=alert.freq_once_per_bar_close) 
  
if checkDownImbalance
    checkDownImbalance := false
    imbTop = low[2]
    imbBottom = high
    if imbTop > imbBottom and showImbalance
        imbalanceBox := box.new(bar_index-2, imbTop,bar_index,imbBottom, bgcolor=imbRedClr, border_color=imbRedClr)
        array.push(arrImbBoxes,imbalanceBox)
        alert("Bearish Imbalance Detected!",freq=alert.freq_once_per_bar_close)

//Top break
if ta.crossover(topBreakCheckSource,topValue) and topBreakBlock == false
    topBreakBlock := true
    isLongBreak := true
    checkUpImbalance := true
    if showBrekout
        line.set_x2(topLine,bar_index)
    if showBoxes
        demandBox := box.new(lastRedIndex-1, lastRedHigh,lastRedIndex+1,lastRedLow, bgcolor=transGreenClr, border_color=greenClr)
        array.push(arrBoxes,demandBox)

//Bottom break
if ta.crossunder(bottomBreakCheckSource,bottomValue) and bottomBreakBlock == false
    bottomBreakBlock := true
    isShortBreak := true
    checkDownImbalance := true
    if showBrekout
        line.set_x2(bottomLine,bar_index)
    if showBoxes
        supplyBox := box.new(lastGreenIndex-1, lastGreenHigh,lastGreenIndex+1,lastGreenLow, bgcolor=transRedClr, border_color=redClr)
        array.push(arrBoxes,supplyBox)

//New up fractal
if upFractal
    topBreakBlock := false
    isLongBreak := false
    topValue := high[n]
    if showBrekout
        topLine := line.new(bar_index[n],topValue,bar_index,topValue, color=upClr, style=lineStyle, width=2)
        if isLongBreak[1] == false
            line.delete(topLine[1])
    
//New down fractal
if downFractal
    bottomBreakBlock := false
    isShortBreak := false
    bottomValue := low[n]
    if showBrekout
        bottomLine := line.new(bar_index[n],bottomValue,bar_index,bottomValue, color=downClr, style=lineStyle, width=2)
        if isShortBreak[1] == false
            line.delete(bottomLine[1])

//Imbalance Box Update 
activeImbBoxes = arrImbBoxes
if array.size(activeImbBoxes) > 0 and hideFilled
	for i = 0 to array.size(activeImbBoxes) - 1
	    bVal = box.get_bottom(array.get(activeImbBoxes, i))
	    tVal = box.get_top(array.get(activeImbBoxes, i)) 

	    if open > tVal and low < tVal
            box.delete(array.get(activeImbBoxes, i)) 
	    if open < bVal and high > bVal
            box.delete(array.get(activeImbBoxes, i)) 

//OB Box state update
activeBoxes = arrBoxes
if array.size(activeBoxes) > 0 and changeColor
	for i = 0 to array.size(activeBoxes) - 1
	    bVal = box.get_bottom(array.get(activeBoxes, i))
	    tVal = box.get_top(array.get(activeBoxes, i))
	    if close < bVal
	        box.set_bgcolor(array.get(activeBoxes, i),transRedClr)
	        box.set_border_color(array.get(activeBoxes, i),redClr)
	    if close > tVal
	        box.set_bgcolor(array.get(activeBoxes, i),transGreenClr)
	        box.set_border_color(array.get(activeBoxes, i),greenClr)

//PLOTS
plotshape(showFractals ? downFractal : na,style=shape.triangleup, location=location.belowbar, offset=-n, color=color.new(color.gray,80), size = size.tiny)
plotshape(showFractals ? upFractal : na, style=shape.triangledown,   location=location.abovebar, offset=-n, color=color.new(color.gray,80), size = size.tiny)

// CPR
daily_cpr = input.int(title="Number of Daily CPR Back", defval=1, minval=0)
Tomorrow_cpr = input.int (title="Number of Tomorrows CPR Look Back", defval=1, minval=0)
showTomorrow = input(defval=true, title='Show Tomorrows CPR')
showDailyCPR = input(defval=true, title='Show Dailys CPR')
todayClose = request.security( syminfo.tickerid , 'D', close,gaps = barmerge.gaps_off, lookahead=barmerge.lookahead_on)
todayHigh = request.security(syminfo.tickerid , 'D', high,gaps = barmerge.gaps_off, lookahead=barmerge.lookahead_on)
todayLow = request.security( syminfo.tickerid, 'D', low,gaps = barmerge.gaps_off, lookahead=barmerge.lookahead_on)

Nextpivot = (todayClose + todayHigh + todayLow)/3
Nextbc = (todayHigh + todayLow) / 2.0
Nexttc = (Nextpivot - Nextbc) + Nextpivot
NextR1 = (Nextpivot*2) - todayLow
NextR2 = Nextpivot+ (todayHigh-todayLow)
NextR3 = todayHigh +  (2*(Nextpivot-todayLow))
NextS1 = (Nextpivot*2) - todayHigh
NextS2 = Nextpivot- (todayHigh-todayLow)
NextS3 = todayLow -  (2*(todayHigh-Nextpivot))

new_bar(res) => ta.change(time(res)) != 0
new_period(condition, src) =>
    result = 0.0
    result := condition ? src : result[1]
    result

pivot = (high + low + close) / 3.0
bc = (high + low) / 2.0
tc = (pivot - bc) + pivot
R1 = (2*pivot) - low
S1 = (2*pivot) - high
R2 = pivot + ( high - low)
S2 = pivot - ( high - low)
R3 = high
S3 = low
R4 = high + (2*(pivot - low))
S4 = low - (2*(high - pivot ))

//Daily Central Pivot Range
dpp = request.security( syminfo.tickerid , 'D', pivot[1], lookahead=barmerge.lookahead_on)
dbc = request.security( syminfo.tickerid , 'D', bc[1], lookahead=barmerge.lookahead_on)
dtc = request.security( syminfo.tickerid , 'D', tc[1], lookahead=barmerge.lookahead_on)
dR1= request.security( syminfo.tickerid , 'D', R1[1], lookahead=barmerge.lookahead_on)
dS1 = request.security( syminfo.tickerid , 'D', S1[1], lookahead=barmerge.lookahead_on)
dR2 = request.security( syminfo.tickerid , 'D', R2[1], lookahead=barmerge.lookahead_on)
dS2 = request.security( syminfo.tickerid , 'D', S2[1], lookahead=barmerge.lookahead_on)
dR3 = request.security( syminfo.tickerid , 'D', R3[1], lookahead=barmerge.lookahead_on)
dS3 = request.security( syminfo.tickerid , 'D', S3[1], lookahead=barmerge.lookahead_on)
dR4 = request.security( syminfo.tickerid , 'D', R4[1], lookahead=barmerge.lookahead_on)
dS4 = request.security( syminfo.tickerid , 'D', S4[1], lookahead=barmerge.lookahead_on)

TcNextpivot = request.security( syminfo.tickerid , 'D', Nextpivot, lookahead=barmerge.lookahead_on)
TcNextbc = request.security( syminfo.tickerid , 'D', Nextbc, lookahead=barmerge.lookahead_on)
TcNexttc = request.security( syminfo.tickerid , 'D', Nexttc, lookahead=barmerge.lookahead_on)
TcNextR1= request.security( syminfo.tickerid , 'D', NextR1, lookahead=barmerge.lookahead_on)
TcNextR2 = request.security( syminfo.tickerid , 'D', NextR2, lookahead=barmerge.lookahead_on)
TcNextR3 = request.security( syminfo.tickerid , 'D', NextR3, lookahead=barmerge.lookahead_on)
TcNextS1 = request.security( syminfo.tickerid , 'D', NextS1, lookahead=barmerge.lookahead_on)
TcNextS2 = request.security( syminfo.tickerid , 'D', NextS2, lookahead=barmerge.lookahead_on)
TcNextS3 = request.security( syminfo.tickerid , 'D', NextS3, lookahead=barmerge.lookahead_on)


one_day = 1000 * 60 * 60 * 24
new_day = daily_cpr > 0 and timenow - time < one_day * daily_cpr and new_bar("D")
dpp_ = new_period(new_day, dpp)
dtc_ = new_period(new_day, dtc)
dbc_ = new_period(new_day, dbc)
dR1_ = new_period(new_day, dR1)
dS1_ = new_period(new_day, dS1)
dR2_ = new_period(new_day, dR2)
dS2_ = new_period(new_day, dS2)
dR3_ = new_period(new_day, dR3)
dS3_ = new_period(new_day, dS3)
dR4_ = new_period(new_day, dR4)
dS4_ = new_period(new_day, dS4)
next_day = Tomorrow_cpr > 0 and timenow - time < one_day * Tomorrow_cpr and new_bar("D")
Nextpivot_ = new_period(next_day, TcNextpivot)
Nextbc_ = new_period(next_day, TcNextbc)
Nexttc_ = new_period(next_day, TcNexttc)
NextR1_= new_period(next_day, TcNextR1)
NextR2_ = new_period(next_day, TcNextR2)
NextR3_ = new_period(next_day, TcNextR3)
NextS1_ = new_period(next_day, TcNextS1)
NextS2_ = new_period(next_day, TcNextS2)
NextS3_ = new_period(next_day, TcNextS3)

timeFrames = timeframe.isminutes?timeframe.multiplier:60
offest_count = math.ceil(375/timeFrames)


plot( showDailyCPR?(timeframe.isintraday ? (dtc_ >= dbc_ ? dtc_ : dbc_) : na):na, title="Daily TC", style= plot.style_circles , color=#2962ff, linewidth=2)
plot( showDailyCPR?(timeframe.isintraday ? dpp_ : na):na, title="Daily PP", style= plot.style_circles, color=#2962ff, linewidth=2)
plot( showDailyCPR?(timeframe.isintraday ? (dtc_ >= dbc_ ? dbc_ : dtc_) : na):na, title="Daily BC", style= plot.style_circles, color=#2962ff, linewidth=2)
plot(showDailyCPR?dR1_:na , title='R1', style= plot.style_circles , color=#429348, linewidth=2)
// plot(showDailyCPR?dR2_:na , title='R2',  style= plot.style_circles , color=#429348, linewidth=2)
// plot(showDailyCPR?dR3_:na , title='PDH',  style= plot.style_circles , color=color.black, linewidth=2)
plot(showDailyCPR?dS1_:na , title='S1', style= plot.style_circles , color=#ff3300, linewidth=2)
// plot(showDailyCPR?dS2_:na , title='S2',  style= plot.style_circles , color=#ff3300, linewidth=2)
// plot(showDailyCPR?dS3_:na , title='PDL',  style= plot.style_circles , color=color.black, linewidth=2)
// plot(showDailyCPR?dR4_:na , title='R3',  style= plot.style_circles , color=#429348, linewidth=2)
// plot(showDailyCPR?dS4_:na , title='S3', style= plot.style_circles , color=#ff3300, linewidth=2)

//--------------------------------------------------------------------
//#region                      Constants
//--------------------------------------------------------------------

color   COLOR_1         = color.green
color   COLOR_2         = color.orange
color   COLOR_3         = color.red
color   COLOR_4         = color.purple
color   COLOR_5         = color.blue
int     HEAD_PADDING    = -2
int     HEAD_TRANSP     = 60
string  LABEL_SIZE      = size.small
string  LABEL_STYLE     = label.style_none
string  LINE_STYLE      = line.style_solid
int     LINE_WIDTH      = 1
int     OFFSET_PADDING  = 4
string  TAIL_STYLE      = line.style_dotted

//#endregion


//--------------------------------------------------------------------
//#region                         Types 
//--------------------------------------------------------------------

// @type Contains the open's data.
type Open 
    int     barIndex
    float   price 
    string  name
    bool    display


// @enum Contains fields with configurable timeframe options as titles.
enum Timeframes
    s5  = "5 seconds"
    s10 = "10 seconds"
    s15 = "15 seconds"
    s30 = "30 seconds"
    m1  = "1 minute"
    m2  = "2 minutes"
    m3  = "3 minutes"
    m5  = "5 minutes"
    m10 = "10 minutes"
    m15 = "15 minutes"
    m30 = "30 minutes"
    m45 = "45 minutes"
    h1  = "1 hour"
    h2  = "2 hours"
    h3  = "3 hours"
    h4  = "4 hours"
    h6  = "6 hours"
    h8  = "8 hours"
    h12 = "12 hours"
    D1  = "1 day"
    W1  = "1 week"
    M1  = "1 month"
    M3  = "3 months"
    M6  = "6 months"
    M12 = "12 months"

//#endregion


//--------------------------------------------------------------------
//#region                        Inputs
//--------------------------------------------------------------------

string      group1                      = "Opens"
string      group2                      = "Style"
string      group3                      = "Preferences"

string      rightOffsetTooltip          = "Extend the current opens to the right of the last bar."
string      tailsTooltip                = "Extend the current opens to the left of the chart."
string      headsTooltip                = "Extend the previous opens to the right."
string      discoverPricesTooltip       = "On the intraday chart, discover the opens on the chart instead of requesting higher-timeframe data." +
                                          "\n\nYou can use this setting when price discrepancies exist between the intraday and end-of-day data feeds."
string      extendedHoursTooltip        = "If the extended trading hours are visible on the intraday chart, display the opens on the pre/post market session."

bool        enableOpenInput1            = input.bool  (true,           title = "",                 group = group1, inline = "#1")
Timeframes  openTimeframeInput1         = input.enum  (Timeframes.D1,  title = "",                 group = group1, inline = "#1", display = display.none)
color       openColorInput1             = input.color (COLOR_1,        title = "",                 group = group1, inline = "#1")
int         openLookbackInput1          = input.int   (1,              title = "",                 group = group1, inline = "#1", minval = 1, maxval = 500, display = display.none)
bool        enableOpenInput2            = input.bool  (true,           title = "",                 group = group1, inline = "#2")
Timeframes  openTimeframeInput2         = input.enum  (Timeframes.W1,  title = "",                 group = group1, inline = "#2", display = display.none)
color       openColorInput2             = input.color (COLOR_2,        title = "",                 group = group1, inline = "#2")
int         openLookbackInput2          = input.int   (1,              title = "",                 group = group1, inline = "#2", minval = 1, maxval = 500, display = display.none)
bool        enableOpenInput3            = input.bool  (true,           title = "",                 group = group1, inline = "#3")
Timeframes  openTimeframeInput3         = input.enum  (Timeframes.M1,  title = "",                 group = group1, inline = "#3", display = display.none)
color       openColorInput3             = input.color (COLOR_3,        title = "",                 group = group1, inline = "#3")
int         openLookbackInput3          = input.int   (1,              title = "",                 group = group1, inline = "#3", minval = 1, maxval = 500, display = display.none)
bool        enableOpenInput4            = input.bool  (false,          title = "",                 group = group1, inline = "#4")
Timeframes  openTimeframeInput4         = input.enum  (Timeframes.M3,  title = "",                 group = group1, inline = "#4", display = display.none)
color       openColorInput4             = input.color (COLOR_4,        title = "",                 group = group1, inline = "#4")
int         openLookbackInput4          = input.int   (1,              title = "",                 group = group1, inline = "#4", minval = 1, maxval = 500, display = display.none)
bool        enableOpenInput5            = input.bool  (true,           title = "",                 group = group1, inline = "#5")
Timeframes  openTimeframeInput5         = input.enum  (Timeframes.M12, title = "",                 group = group1, inline = "#5", display = display.none)
color       openColorInput5             = input.color (COLOR_5,        title = "",                 group = group1, inline = "#5")
int         openLookbackInput5          = input.int   (1,              title = "",                 group = group1, inline = "#5", minval = 1, maxval = 500, display = display.none)
int         rightOffsetInput            = input.int   (20,             title = "Offset",           group = group2, inline = "Offset", tooltip = rightOffsetTooltip, minval = 1, display = display.none)
bool        enableTailsInput            = input.bool  (false,          title = "Show Tails",       group = group2, tooltip = tailsTooltip)
bool        enableHeadsInput            = input.bool  (false,          title = "Show Projections", group = group2, tooltip = headsTooltip)
bool        discoverPricesInput         = input.bool  (false,          title = "Discover Prices",  group = group3, tooltip = discoverPricesTooltip)
bool        enableExtendedSessionInput  = input.bool  (false,          title = "Extended Hours",   group = group3, tooltip = extendedHoursTooltip)

//#endregion


//--------------------------------------------------------------------
//#region                   Functions & methods
//--------------------------------------------------------------------

// @function Check if the open for the specified `timeframe` can be displayed on the chart context.
// @returns  simple bool
method isVisible(simple string timeframe) =>
    timeframe.in_seconds(timeframe) > timeframe.in_seconds()


// @function Detect changes of opens.
// @returns  series bool
method change(
     simple string timeframe,
     series int    timeframeTime,
     simple bool   discoverPrice,
     simple bool   discoverExtendedPrice
     ) =>

    switch 
        discoverExtendedPrice => timeframe.change(timeframe)
        discoverPrice         => ta.change(timeframeTime) > 0 or (barstate.isfirst and time == timeframeTime)
        =>                       ta.change(timeframeTime) > 0 or barstate.isfirst


// @function Request the data in the specified `timeframe` context.
// @returns  ([int, float]) The open's time and price.
method request(string timeframe, bool extendedSession) =>
    string tickerId = ticker.new(syminfo.prefix, syminfo.ticker, extendedSession ? session.extended : session.regular)
    request.security(tickerId, timeframe, [time, open], lookahead = barmerge.lookahead_on)


// @function Check if the specified `timeframe` returns end-of-day data.
// @returns  bool
method higherTimeframeFeed(simple string timeframe) =>
    timeframe.in_seconds(timeframe) >= timeframe.in_seconds("D") 


// @function Check if the open can be sourced from the chart data.
// @returns  bool
discoverPrice(simple string timeframe, simple bool discovery) =>
    discovery and higherTimeframeFeed(timeframe) and timeframe.isintraday


// @function Check if the extended session open can be sourced from the chart.
// @returns  bool
discoverExtendedPrice(simple string timeframe, simple bool extendedSession) => 
    extendedSession and higherTimeframeFeed(timeframe) and syminfo.session == session.extended


// @function Check if the open time belongs to the previous bar.
// @returns  bool
adjustStartBarIndex(int t) =>
    time_close[1] > t


// @function Calculate the right position of the open level.
// @returns  (int) The bar index. 
getRightBarIndex(int padding = 0) =>
    bar_index + rightOffsetInput + padding * OFFSET_PADDING


// @function Produce the `timeframe` parameter from the given user input.
// @returns  string
method param(simple Timeframes input) =>
    switch input
        Timeframes.s5  => "5S"
        Timeframes.s10 => "10S"
        Timeframes.s15 => "15S"
        Timeframes.s30 => "30S"
        Timeframes.m1  => "1"
        Timeframes.m2  => "2"
        Timeframes.m3  => "3"
        Timeframes.m5  => "5"
        Timeframes.m10 => "10"
        Timeframes.m15 => "15"
        Timeframes.m30 => "30"
        Timeframes.m45 => "45"
        Timeframes.h1  => "60"
        Timeframes.h2  => "120"
        Timeframes.h3  => "180"
        Timeframes.h4  => "240"
        Timeframes.h6  => "360"
        Timeframes.h8  => "480"
        Timeframes.h12 => "720"
        Timeframes.D1  => "1D"
        Timeframes.W1  => "1W"
        Timeframes.M1  => "1M" 
        Timeframes.M3  => "3M"
        Timeframes.M6  => "6M"
        Timeframes.M12 => "12M"


// @function Return the short display string for the specified `timeframe` string.
// @returns  string
method displayString(string this) =>
    // Get the readable format.
    string _str = switch this
        "1"     => "m"
        "2"     => "2m"
        "3"     => "3m"
        "5"     => "5m"
        "10"    => "10m"
        "15"    => "15m"
        "30"    => "30m"
        "45"    => "45m"
        "60"    => "H"
        "120"   => "2H"
        "180"   => "3H"
        "240"   => "4H"
        "360"   => "6H"
        "480"   => "8H"
        "720"   => "12H"
        "1440"  => "24H"
        "1D"    => "D"
        "1W"    => "W"
        "1M"    => "M"
        "12M"   => "Y"
        => this

    // Add spacing.
    switch str.length(_str)
        1 => _str + "   "
        2 => _str + "     "
        3 => _str + "       "


// @function Create and update the open level. An open is composed of a label, a "body" line, and optional "tail" and "head" line extensions.
// @returns  void
draw(bool change, Open openData, int lookback, color color, int padding) =>
    // @variable The reference of the last open line.
    var line _bodyLine = na

    // @variable The reference of the last open label.
    var label _label = label.new(
         x         = na,
         y         = na,
         text      = openData.name,
         style     = LABEL_STYLE,
         textcolor = color,
         size      = LABEL_SIZE
         )

    // @variable The reference of the last open left extending line.
    var line _tailLine = line.new(
         x1     = na,
         y1     = na,
         x2     = na,
         y2     = na,
         color  = color,
         style  = TAIL_STYLE,
         width  = LINE_WIDTH,
         extend = extend.left
         )

    // @variable The collection of historical open lines.
    var array<line> _bodyLineArray  = array.new_line()

    // @variable The collection of historical right extending open lines.
    var array<line> _headLineArray  = array.new_line()


    // Update the old open and create the new open.

    if change
        int _x2 = getRightBarIndex()

        // Anchor the previous open end position.
        _bodyLine.set_x2(openData.barIndex -1)

        // Create the previous open "head".
        if enableHeadsInput
            _headLineArray.push(
                 line.new(
                     x1    = openData.barIndex -1,
                     x2    = openData.barIndex,
                     y1    = _bodyLine.get_y1(),
                     y2    = _bodyLine.get_y2(),
                     color = color.new(color, HEAD_TRANSP),
                     style = LINE_STYLE,
                     width = LINE_WIDTH
                     )
                 )

            // Trim the exceeding number of drawings.
            if _headLineArray.size() > lookback -1
                line.delete(_headLineArray.shift())

        // Update the last open label position and tooltip.
        _label.set_xy(_x2, openData.price)
        _label.set_tooltip(str.tostring(openData.price, format.mintick))

        // Create and store the last open line.
        _bodyLine := line.new(
             x1    = openData.barIndex,
             x2    = _x2,
             y1    = openData.price,
             y2    = openData.price,
             color = color,
             style = LINE_STYLE,
             width = LINE_WIDTH
             )
        array.push(_bodyLineArray, _bodyLine)

        // Trim the exceeding number of drawings.
        if _bodyLineArray.size() > lookback
            line.delete(_bodyLineArray.shift())

        // Create the last open "tail".
        if enableTailsInput
            _tailLine.set_xy1(openData.barIndex -1, openData.price)
            _tailLine.set_xy2(openData.barIndex,    openData.price)


    // Update the right position of the "body" and "heads" lines.

    if barstate.islast
        if enableHeadsInput
            int _x2 = getRightBarIndex(HEAD_PADDING)
            for _head in _headLineArray
                _head.set_x2(_x2)

        int _x2 = getRightBarIndex(padding)
        _bodyLine.set_x2(_x2)
        _label.set_x(_x2)


// @function Get the padding to apply to the open right position for not overlapping the other open labels.
// @returns  int
method padding(array<Open> this, int idx, float proximityThreshold) =>
    int _padding = 0

    // Open #2, #3, #4, and #5 can share the same open with #1.
    if idx > 0 and this.get(0).display and math.abs(this.get(0).price - this.get(idx).price) <= proximityThreshold
        _padding += 1

    // Open #3, #4, and #5 can share the same open with #2.
    if idx > 1 and this.get(1).display and math.abs(this.get(1).price - this.get(idx).price) <= proximityThreshold
        _padding += 1

    // Open #4 and #5 can share the same open with #3.
    if idx > 2 and this.get(2).display and math.abs(this.get(2).price - this.get(idx).price) <= proximityThreshold
        _padding += 1

    // Open #5 can share the same open with #4.
    if idx > 3 and this.get(3).display and math.abs(this.get(3).price - this.get(idx).price) <= proximityThreshold
        _padding += 1    
    
    _padding


// @function Update the open levels.
// @returns  (bool) Is true if the open changes.
update(
     Open           data,
     simple string  tf,
     simple bool    extendedSession,
     simple bool    discoverPrice,
     simple bool    discoverExtendedPrice
     ) =>

    // @variable The `open` and `time` requested from the timeframe context.
    [_tfTime, _tfOpen] = tf.request(extendedSession)

    // @variable Is true when the timeframe changes.
    bool _change = tf.change(_tfTime, discoverPrice, discoverExtendedPrice)

    // @variable Is true when pinpointing the opening bar index on the previous bar.
    bool _adjust = adjustStartBarIndex(_tfTime)

    // @variable Is true when sourcing the opening price from the chart context.
    bool _discovery = discoverPrice or discoverExtendedPrice

    if _change
        data.price    := _discovery ? open : _tfOpen
        data.barIndex := _discovery ? bar_index : (_adjust ? bar_index -1 : bar_index)
        
    _change

//#endregion


//--------------------------------------------------------------------
//#region                 Variables declarations
//--------------------------------------------------------------------

// @variable The `timeframe` parameters produced from the enum input selections.
var string timeframe1 = openTimeframeInput1.param()
var string timeframe2 = openTimeframeInput2.param()
var string timeframe3 = openTimeframeInput3.param()
var string timeframe4 = openTimeframeInput4.param()
var string timeframe5 = openTimeframeInput5.param()


// @variable Are true when we can display the opens on the chart.
var simple bool display1 = enableOpenInput1 and timeframe1.isVisible()
var simple bool display2 = enableOpenInput2 and timeframe2.isVisible()
var simple bool display3 = enableOpenInput3 and timeframe3.isVisible()
var simple bool display4 = enableOpenInput4 and timeframe4.isVisible()
var simple bool display5 = enableOpenInput5 and timeframe5.isVisible()


// @variable Are true when sourcing the open prices from the chart instead of the requested timeframe context.
var simple bool discoverPrice1 = discoverPrice(timeframe1, discoverPricesInput)
var simple bool discoverPrice2 = discoverPrice(timeframe2, discoverPricesInput)
var simple bool discoverPrice3 = discoverPrice(timeframe3, discoverPricesInput)
var simple bool discoverPrice4 = discoverPrice(timeframe4, discoverPricesInput)
var simple bool discoverPrice5 = discoverPrice(timeframe5, discoverPricesInput)


// @variable Is true when we should plot the opens on the extended trading hours.
var simple bool extendedSession = enableExtendedSessionInput and syminfo.session == session.extended


// @variable Are true when we should source the open prices from the chart instead of the requested timeframe context.
var simple bool discoverExtendedPrice1 = discoverExtendedPrice(timeframe1, extendedSession)
var simple bool discoverExtendedPrice2 = discoverExtendedPrice(timeframe2, extendedSession)
var simple bool discoverExtendedPrice3 = discoverExtendedPrice(timeframe3, extendedSession)
var simple bool discoverExtendedPrice4 = discoverExtendedPrice(timeframe4, extendedSession)
var simple bool discoverExtendedPrice5 = discoverExtendedPrice(timeframe5, extendedSession)


// @variable The `Open` UDTs. 
var Open open1 = Open.new(name = timeframe1.displayString(), display = display1)
var Open open2 = Open.new(name = timeframe2.displayString(), display = display2)
var Open open3 = Open.new(name = timeframe3.displayString(), display = display3)
var Open open4 = Open.new(name = timeframe4.displayString(), display = display4)
var Open open5 = Open.new(name = timeframe5.displayString(), display = display5)


// @variable The collection of last `Open`. 
var array<Open> openArray = array.from(open1, open2, open3, open4, open5)


// @variable The maximum distance to determine if two levels overlap each other.
float proximityPaddingThreshold = ta.atr(10) /2

//#endregion


//--------------------------------------------------------------------
//#region                         Logic
//--------------------------------------------------------------------

bool change1 = if display1
    update(open1, timeframe1, extendedSession, discoverPrice1, discoverExtendedPrice1)


bool change2 = if display2
    update(open2, timeframe2, extendedSession, discoverPrice2, discoverExtendedPrice2)


bool change3 = if display3
    update(open3, timeframe3, extendedSession, discoverPrice3, discoverExtendedPrice3)


bool change4 = if display4
    update(open4, timeframe4, extendedSession, discoverPrice4, discoverExtendedPrice4)


bool change5 = if display5
    update(open5, timeframe5, extendedSession, discoverPrice5, discoverExtendedPrice5)

//#endregion


//--------------------------------------------------------------------
//#region                        Visuals
//--------------------------------------------------------------------

//#region - Draw the open levels.

if display5
    draw(
         change5,
         open5,
         openLookbackInput5,
         openColorInput5,
         barstate.islast ? openArray.padding(4, proximityPaddingThreshold) : 0
         )


if display4
    draw(
         change4,
         open4,
         openLookbackInput4,
         openColorInput4,
         barstate.islast ? openArray.padding(3, proximityPaddingThreshold) : 0
         )


if display3
    draw(
         change3,
         open3,
         openLookbackInput3,
         openColorInput3,
         barstate.islast ? openArray.padding(2, proximityPaddingThreshold) : 0
         )


if display2
    draw(
         change2,
         open2,
         openLookbackInput2,
         openColorInput2,
         barstate.islast ? openArray.padding(1, proximityPaddingThreshold) : 0
         )


if display1
    draw(
         change1,
         open1,
         openLookbackInput1,
         openColorInput1,
         0
         )

//#endregion


//#region - Plot the open prices on the `status line`, `price scale`, `data window` as well for providing alert conditions.

displayControls = display.status_line + display.price_scale + display.data_window

plot(
     series   = open1.price,
     title    = "#1",
     color    = openColorInput1,
     editable = false,
     display  = enableOpenInput1 ? displayControls : display.none
     )

plot(
     series   = open2.price,
     title    = "#2",
     color    = openColorInput2,
     editable = false,
     display  = enableOpenInput2 ? displayControls : display.none
     )

plot(
     series = open3.price,
     title    = "#3",
     color    = openColorInput3,
     editable = false,
     display  = enableOpenInput3 ? displayControls : display.none
     )

plot(
     series   = open4.price,
     title    = "#4",
     color    = openColorInput4,
     editable = false,
     display  = enableOpenInput4 ? displayControls : display.none
     )
     
plot(
     series   = open5.price,
     title    = "#5",
     color    = openColorInput5,
     editable = false,
     display  = enableOpenInput5 ? displayControls : display.none
     )


General_settings        = 'General settings'
tmf               = input.timeframe("","Timeframe", group = General_settings)
fvg_usewidth      = true
fvg_gapwidth      = 0.009
fvg_method        = '%'

mitgationTypeWick = input.string("Wick","Mitigation Type",options = ["Wick","Close"],inline = "mitper", group = General_settings) == "Wick"
mitgPer           = input.int(50,"Mitigation %",minval = 1,maxval = 100,inline = "mitper",step = 10, group = General_settings)

FVG_settings        = 'FVG settings'
fvgStyle          = input.string(line.style_dotted,"FVG Style",options = [line.style_solid,line.style_dotted,line.style_dashed], group = FVG_settings)
fvgLabl           = input.string(size.small,"Lable Size",options = [size.auto,size.tiny,size.normal,size.small,size.large], group = General_settings)

BPR_settings        = 'BPR settings'
bprStyle          = input.string(line.style_solid,"BPR Style",options = [line.style_solid,line.style_dotted,line.style_dashed], group = BPR_settings)
showhist          = false

numFVG            = input.int(2,"FVG Count", group = FVG_settings)
numBRB            = input.int(2,"BRB Count", group = BPR_settings)

Style_settings        = 'Color settings'
styleOption       = input.string("TLAB colors",  title = "Style:â€‡â€‡â€‡â€‡â€‡",  options = ["TLAB colors", "standart colors", "Monochrome black BG", "Monochrome grey BG", "Custom"], inline = 'h5', group = Style_settings)
Custom_S          = input.color (color.rgb(0, 4, 255) , 'Custom color ', group = Style_settings)

colorHigh = styleOption == "TLAB colors"           ? #9c9c9c   :
          styleOption   == "standart colors"       ? color.red :
          styleOption   == "Monochrome grey BG"    ? #000000   :
          styleOption   == "Monochrome black BG"   ? #9c9c9c   :
          styleOption   == "Custom"                ? Custom_S    : na

colorLow = styleOption == "TLAB colors"           ? #9c9c9c :
          styleOption  == "standart colors"       ? #00d451 :
          styleOption  == "Monochrome grey BG"    ? #000000 :
          styleOption  == "Monochrome black BG"   ? #9c9c9c :
          styleOption  == "Custom"                ? Custom_S  :na

imbalance_detection(top, btm, condition,atr) =>
    var is_width = true

    if fvg_usewidth
        dist = top - btm

        is_width := switch fvg_method
            'Points' => dist > fvg_gapwidth
            '%' => dist / btm * 100 > fvg_gapwidth
        is_width

    is_true = condition and is_width
    is_true

type fvgDetails
	int   Type = 0
	float Top = na
	float Btm = na
	int   left = na
    int   left2 = na
	int   right = na
    int   cnt = 0
    color   fvgClr=na

getFVG() =>
    atr = ta.atr(200)
    fvgDetails fd = fvgDetails.new()

    isFvgBull = imbalance_detection(low, high[2], low  > high[2] and close[1] > high[2],atr)
    isFvgBear = imbalance_detection(low[2], high, high < low[2]  and close[1] < low[2] ,atr)

    if  isFvgBull
        fd.Type     := 1
        fd.Top      := low
        fd.Btm      := high[2]
        fd.left     := time
        fd.left2    := time[2]
        fd.right    := time
        fd.fvgClr   := colorLow

    if  isFvgBear
        fd.Type  := -1
        fd.Top   := low[2]
        fd.Btm   := high
        fd.left  := time[2]
        fd.left2 := time
        fd.right := time 
        fd.fvgClr   := colorHigh

    [fd,open, close,high,low,high[1],low[1],close[1]]

[fd,open_, close_,high_,low_,high_p,low_p,close_p] = request.security(syminfo.tickerid,tmf, getFVG())

var arrFVDD = array.new<fvgDetails>(0)
var arrFVDDType = array.new_bool(0)

var arrFVDLineTop = array.new_line(0)
var arrFVDLineBtm = array.new_line(0)

var arrFVDLblTop = array.new_label(0)

if  arrFVDLineTop.size() > numFVG
    arrFVDLineTop.pop().delete()
    arrFVDLineBtm.pop().delete()
    arrFVDLblTop.pop().delete()
    arrFVDDType.pop()

var arrFVD_BPR = array.new<fvgDetails>(0)
var arrFVD_BPRBox = array.new_box(0)

if arrFVD_BPRBox.size() > numBRB
    arrFVD_BPRBox.pop().delete()
    arrFVD_BPR.pop() 

addtimt = 5*(time[1] - time[2]) 
if open_ != open_[1]
    isBPR = false
    if not na(fd) and not na(fd[1])
        if arrFVDD.size() > 0  and (fd.Type == 1 or fd.Type == -1)
            i = 0
            while i < arrFVDD.size() 
                odlfd = arrFVDD.get(i)
                c1 =  fd.Top <= odlfd.Top and fd.Btm >= odlfd.Btm
                c2 = fd.Top <= odlfd.Top and fd.Top > odlfd.Btm  and fd.Btm < odlfd.Btm 
                c3 = fd.Top > odlfd.Top and fd.Btm >= odlfd.Btm and fd.Btm < odlfd.Top
                c4 = fd.Top >= odlfd.Top and fd.Btm <= odlfd.Btm

                if c1 or c2 or c3 or c4
                    top_ = fd.Top 
                    btm_ = fd.Btm
                    bleft_ = odlfd.left
                    if c2
                        top_ := fd.Top 
                        btm_ := odlfd.Btm
                    else if c3
                        top_ := odlfd.Top 
                        btm_ := fd.Btm
                    else if c4
                        top_ := odlfd.Top 
                        btm_ := odlfd.Btm
    
                    isBPR := true
                    arrFVD_BPR.unshift(fvgDetails.new(fd.Type,top_,btm_,bleft_,time,0))
                    arrFVD_BPRBox.unshift(box.new(bleft_, top_, time, btm_, border_color = fd.fvgClr, bgcolor = na, xloc = xloc.bar_time,border_style = bprStyle,text = "BPR",text_size = fvgLabl,text_halign = text.align_right,text_color = fd.fvgClr))
    
                i += 1

    bullMit = mitgationTypeWick ? low_ : close_
    bearMit = mitgationTypeWick ? high_ : close_

    //fvg testing
    if arrFVDDType.size() > 0
        i = 0
        while i < arrFVDDType.size()
            fdnTpe = arrFVDDType.get(i)
            //fdn = arrFVDDBox.get(i)
            fdnLblTop = arrFVDLblTop.get(i)
            //fdnLblBtm = arrFVDLblBtm.get(i)

            fdnLinTop = arrFVDLineTop.get(i)
            fdnLinBtm = arrFVDLineBtm.get(i)

            fdnLblTop.set_x(time+addtimt)
            //fdnLblBtm.set_x(time)

            fdnLinTop.set_x2(time+addtimt)
            fdnLinBtm.set_x2(time+addtimt)

            minval = math.min(fdnLinBtm.get_y1(),fdnLinTop.get_y1())
            maxvla = math.max(fdnLinBtm.get_y1(),fdnLinTop.get_y1())
            midPnt = (maxvla - minval)*mitgPer*0.01
            if fdnTpe 
                if bullMit < (maxvla - midPnt)//fdn.get_bottom()
                    arrFVDLblTop.remove(i).delete()
                    arrFVDLineTop.remove(i).delete()
                    arrFVDLineBtm.remove(i).delete()
                    arrFVDDType.remove(i)
                    i -= 1
            else
                if bearMit > (minval + midPnt)//fdn.get_top()
                    arrFVDLblTop.remove(i).delete()
                    arrFVDLineTop.remove(i).delete()
                    arrFVDLineBtm.remove(i).delete()
                    arrFVDDType.remove(i)
                    i -= 1

            i += 1


    //bpr testing
    if arrFVD_BPR.size() > 0  
        i = 0
        while i < arrFVD_BPR.size()
            fdn = arrFVD_BPR.get(i)

            arrFVD_BPRBox.get(i).set_right(time+addtimt)

            minval = math.min(fdn.Top,fdn.Btm)
            maxvla = math.max(fdn.Top,fdn.Btm)
            midPnt = (maxvla - minval)*mitgPer*0.01

            if fdn.Type == 1
                if bullMit < (maxvla - midPnt)
                    bx = arrFVD_BPRBox.remove(i)
                    if showhist
                        bx.set_right(time+addtimt)
                    else
                        bx.delete()
                    arrFVD_BPR.remove(i)
                    i -= 1
            else
                if bearMit > (minval + midPnt)
                    bx = arrFVD_BPRBox.remove(i)
                    if showhist
                        bx.set_right(time+addtimt)
                    else
                        bx.delete()
                    arrFVD_BPR.remove(i)
                    i -= 1

            i += 1

    bullMitp = mitgationTypeWick ? low_p : close_p
    bearMitp = mitgationTypeWick ? high_p : close_p

    if arrFVDD.size() > 0
        i = 0
        while i < arrFVDD.size()
            fdn = arrFVDD.get(i)
            
            minval = math.min(fdn.Top,fdn.Btm)
            maxvla = math.max(fdn.Top,fdn.Btm)
            midPnt = (maxvla - minval)*mitgPer*0.01

            if fdn.Type == 1 
                if  bullMitp < (maxvla - midPnt)
                    arrFVDD.remove(i)
                    i -= 1
            else
                if  bearMitp > (minval + midPnt)
                    arrFVDD.remove(i)
                    i -= 1
            i += 1

   
    if not na(fd) and not na(fd[1])
        if fd.Type == 1 or fd.Type == -1 //(fd[1]).left != fd.left   
            arrFVDD.unshift(fd)
            if not isBPR
                arrFVDDType.unshift(fd.Type == 1)
                arrFVDLineTop.unshift(line.new(fd.left, fd.Top,time+addtimt, fd.Top,style = fvgStyle,color = fd.fvgClr,xloc = xloc.bar_time))
                arrFVDLineBtm.unshift(line.new(fd.left2, fd.Btm,time+addtimt, fd.Btm,style = fvgStyle,color = fd.fvgClr,xloc = xloc.bar_time))
                arrFVDLblTop.unshift(label.new(time+addtimt,  (fd.Top+fd.Btm)/2,color = #ff525200,xloc = xloc.bar_time,style = label.style_label_right,size = fvgLabl,text = "FVG",textcolor = fd.fvgClr))
               

